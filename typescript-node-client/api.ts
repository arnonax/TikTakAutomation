/**
 * Egged.PickU API
 * The API for Egged.PickU services. See [link to md preview](https://dev.azure.com/egged/Skip/_git/tiktak-server-api?path=%2Frnd%2Fdev%2Fsrc%2Fswagger%2Findex.md&_a=preview)
 *
 * OpenAPI spec version: v2
 * Contact: support@egged.co.il
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require("request");
import http = require("http");
import Promise = require("bluebird");

let defaultBasePath = "https://localhost";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
	"string",
	"boolean",
	"double",
	"integer",
	"long",
	"float",
	"number",
	"any",
];

class ObjectSerializer {
	public static findCorrectType(data: any, expectedType: string) {
		if (data == undefined) {
			return expectedType;
		} else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
			return expectedType;
		} else if (expectedType === "Date") {
			return expectedType;
		} else {
			if (enumsMap[expectedType]) {
				return expectedType;
			}

			if (!typeMap[expectedType]) {
				return expectedType; // w/e we don't know the type
			}

			// Check the discriminator
			let discriminatorProperty = typeMap[expectedType].discriminator;
			if (discriminatorProperty == null) {
				return expectedType; // the type does not have a discriminator. use it.
			} else {
				if (data[discriminatorProperty]) {
					return data[discriminatorProperty]; // use the type given in the discriminator
				} else {
					return expectedType; // discriminator was not present (or an empty string)
				}
			}
		}
	}

	public static serialize(data: any, type: string) {
		if (data == undefined) {
			return data;
		} else if (primitives.indexOf(type.toLowerCase()) !== -1) {
			return data;
		} else if (type.lastIndexOf("Array<", 0) === 0) {
			// string.startsWith pre es6
			let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
			subType = subType.substring(0, subType.length - 1); // Type> => Type
			let transformedData: any[] = [];
			for (let index in data) {
				let date = data[index];
				transformedData.push(ObjectSerializer.serialize(date, subType));
			}
			return transformedData;
		} else if (type === "Date") {
			return data.toString();
		} else {
			if (enumsMap[type]) {
				return data;
			}
			if (!typeMap[type]) {
				// in case we dont know the type
				return data;
			}

			// get the map for the correct type.
			let attributeTypes = typeMap[type].getAttributeTypeMap();
			let instance: { [index: string]: any } = {};
			for (let index in attributeTypes) {
				let attributeType = attributeTypes[index];
				instance[attributeType.baseName] = ObjectSerializer.serialize(
					data[attributeType.name],
					attributeType.type
				);
			}
			return instance;
		}
	}

	public static deserialize(data: any, type: string) {
		// polymorphism may change the actual type.
		type = ObjectSerializer.findCorrectType(data, type);
		if (data == undefined) {
			return data;
		} else if (primitives.indexOf(type.toLowerCase()) !== -1) {
			return data;
		} else if (type.lastIndexOf("Array<", 0) === 0) {
			// string.startsWith pre es6
			let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
			subType = subType.substring(0, subType.length - 1); // Type> => Type
			let transformedData: any[] = [];
			for (let index in data) {
				let date = data[index];
				transformedData.push(
					ObjectSerializer.deserialize(date, subType)
				);
			}
			return transformedData;
		} else if (type === "Date") {
			return new Date(data);
		} else {
			if (enumsMap[type]) {
				// is Enum
				return data;
			}

			if (!typeMap[type]) {
				// dont know the type
				return data;
			}
			let instance = new typeMap[type]();
			let attributeTypes = typeMap[type].getAttributeTypeMap();
			for (let index in attributeTypes) {
				let attributeType = attributeTypes[index];
				instance[attributeType.name] = ObjectSerializer.deserialize(
					data[attributeType.baseName],
					attributeType.type
				);
			}
			return instance;
		}
	}
}

/**
 * Represent the information about a specific travel.
 */
export class ActiveTravelsResponse {
	/**
	 * Represents the user id (the traveler)
	 */
	"userId"?: string;
	/**
	 * Represent the unix time when the travel was started
	 */
	"startedOn"?: number;
	/**
	 * Represent the unix time when the state was ended
	 */
	"endedOn"?: number;
	/**
	 * The id of the travel that was created.
	 */
	"travelId"?: string;
	/**
	 * Represents the provider travelId
	 */
	"providerId"?: string;
	/**
	 * Represents the route option used for the travel
	 */
	"travelDetails"?: Travel;
	/**
	 * Represents the status of the travel
	 */
	"travelState"?: ActiveTravelsResponse.TravelStateEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
		{
			name: "startedOn",
			baseName: "startedOn",
			type: "number",
		},
		{
			name: "endedOn",
			baseName: "endedOn",
			type: "number",
		},
		{
			name: "travelId",
			baseName: "travelId",
			type: "string",
		},
		{
			name: "providerId",
			baseName: "providerId",
			type: "string",
		},
		{
			name: "travelDetails",
			baseName: "travelDetails",
			type: "Travel",
		},
		{
			name: "travelState",
			baseName: "travelState",
			type: "ActiveTravelsResponse.TravelStateEnum",
		},
	];

	static getAttributeTypeMap() {
		return ActiveTravelsResponse.attributeTypeMap;
	}
}

export namespace ActiveTravelsResponse {
	export enum TravelStateEnum {
		None = <any>"none",
		Assigned = <any>"assigned",
		Pending = <any>"pending",
		NotAvailable = <any>"notAvailable",
		NoShow = <any>"noShow",
		Arrived = <any>"arrived",
		Bordered = <any>"bordered",
		Finished = <any>"finished",
		Canceled = <any>"canceled",
	}
}
export class AuthenticationTokenRequest {
	/**
	 * A JWT token
	 */
	"token"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "token",
			baseName: "token",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return AuthenticationTokenRequest.attributeTypeMap;
	}
}

/**
 * Represent the authentication token response
 */
export class AuthenticationTokenResponse {
	/**
	 * The authentication token created for the user
	 */
	"authenticationToken"?: string;
	/**
	 * The refresh token created for the user
	 */
	"refreshToken"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "authenticationToken",
			baseName: "authenticationToken",
			type: "string",
		},
		{
			name: "refreshToken",
			baseName: "refreshToken",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return AuthenticationTokenResponse.attributeTypeMap;
	}
}

/**
 * Represent an authenticated user response
 */
export class BackofficeUserInfoResponse {
	/**
	 * The user id
	 */
	"userId"?: string;
	/**
	 * The userName or the emmail of the user
	 */
	"userName"?: string;
	/**
	 * The role of the user
	 */
	"role"?: string;
	/**
	 * The status of the user
	 */
	"status"?: string;
	/**
	 * The time when the user was created
	 */
	"createdOn"?: number;
	/**
	 * The time when the authentication was refreshed
	 */
	"refreshedOn"?: number;
	/**
	 * The time when the authentication was refreshed
	 */
	"expireOn"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
		{
			name: "userName",
			baseName: "userName",
			type: "string",
		},
		{
			name: "role",
			baseName: "role",
			type: "string",
		},
		{
			name: "status",
			baseName: "status",
			type: "string",
		},
		{
			name: "createdOn",
			baseName: "createdOn",
			type: "number",
		},
		{
			name: "refreshedOn",
			baseName: "refreshedOn",
			type: "number",
		},
		{
			name: "expireOn",
			baseName: "expireOn",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return BackofficeUserInfoResponse.attributeTypeMap;
	}
}

export class Bounds {
	"northeast"?: Location;
	"southwest"?: Location;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "northeast",
			baseName: "northeast",
			type: "Location",
		},
		{
			name: "southwest",
			baseName: "southwest",
			type: "Location",
		},
	];

	static getAttributeTypeMap() {
		return Bounds.attributeTypeMap;
	}
}

/**
 * Represent the change password request
 */
export class ChangePasswordRequest {
	/**
	 * The unique user-name of the user
	 */
	"userName"?: string;
	/**
	 * The user's password
	 */
	"password"?: string;
	/**
	 * The user's new password
	 */
	"newPassword"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "userName",
			baseName: "userName",
			type: "string",
		},
		{
			name: "password",
			baseName: "password",
			type: "string",
		},
		{
			name: "newPassword",
			baseName: "newPassword",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return ChangePasswordRequest.attributeTypeMap;
	}
}

/**
 * Represent the SECURED information about the payment-method
 */
export class CreditCard {
	/**
	 * The Id of the credit card
	 */
	"id"?: string;
	/**
	 * The token of the credit card
	 */
	"token"?: string;
	/**
	 * The expiration Month.
	 */
	"expirationMonth"?: number;
	/**
	 * The expiration Year.
	 */
	"expirationYear"?: number;
	/**
	 * The 4 last digits of the payment method as hint for verification.
	 */
	"hint"?: string;
	/**
	 * The status of the payment method
	 */
	"status"?: CreditCard.StatusEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "id",
			baseName: "id",
			type: "string",
		},
		{
			name: "token",
			baseName: "token",
			type: "string",
		},
		{
			name: "expirationMonth",
			baseName: "expirationMonth",
			type: "number",
		},
		{
			name: "expirationYear",
			baseName: "expirationYear",
			type: "number",
		},
		{
			name: "hint",
			baseName: "hint",
			type: "string",
		},
		{
			name: "status",
			baseName: "status",
			type: "CreditCard.StatusEnum",
		},
	];

	static getAttributeTypeMap() {
		return CreditCard.attributeTypeMap;
	}
}

export namespace CreditCard {
	export enum StatusEnum {
		None = <any>"none",
		Pending = <any>"pending",
		Active = <any>"active",
		Blocked = <any>"blocked",
		Expired = <any>"expired",
	}
}
export class Data {
	"geocodedWaypoints"?: Array<GeocodedWaypoint>;
	"routes"?: Array<Route>;
	"status"?: string;
	"requestId"?: string;
	"travelOption"?: TravelOptionState;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "geocodedWaypoints",
			baseName: "geocoded_waypoints",
			type: "Array<GeocodedWaypoint>",
		},
		{
			name: "routes",
			baseName: "routes",
			type: "Array<Route>",
		},
		{
			name: "status",
			baseName: "status",
			type: "string",
		},
		{
			name: "requestId",
			baseName: "requestId",
			type: "string",
		},
		{
			name: "travelOption",
			baseName: "travelOption",
			type: "TravelOptionState",
		},
	];

	static getAttributeTypeMap() {
		return Data.attributeTypeMap;
	}
}

export class Distance {
	"text"?: string;
	"value"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "text",
			baseName: "text",
			type: "string",
		},
		{
			name: "value",
			baseName: "value",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return Distance.attributeTypeMap;
	}
}

export class Duration {
	"text"?: string;
	"value"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "text",
			baseName: "text",
			type: "string",
		},
		{
			name: "value",
			baseName: "value",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return Duration.attributeTypeMap;
	}
}

/**
 * Represent the register verification request
 */
export class EmailLoginRequest {
	/**
	 * The user's email
	 */
	"email"?: string;
	/**
	 * The user's password
	 */
	"password"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "email",
			baseName: "email",
			type: "string",
		},
		{
			name: "password",
			baseName: "password",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return EmailLoginRequest.attributeTypeMap;
	}
}

/**
 * Represent the email request
 */
export class EmailRequest {
	/**
	 * The email of sender
	 */
	"from"?: string;
	/**
	 * The email of recipients
	 */
	"to"?: string;
	/**
	 * Additional email recipients
	 */
	"cc"?: string;
	/**
	 * Additional email recipients
	 */
	"bcc"?: string;
	/**
	 * The email sender
	 */
	"sender"?: string;
	/**
	 * The email recipient
	 */
	"replyTo"?: string;
	/**
	 * The email subject
	 */
	"subject"?: string;
	/**
	 * The email text
	 */
	"text"?: string;
	/**
	 * The email html
	 */
	"html"?: string;
	/**
	 * The email priority
	 */
	"priority"?: string;
	/**
	 * The email attachments
	 */
	"attachments"?: Array<any>;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "from",
			baseName: "from",
			type: "string",
		},
		{
			name: "to",
			baseName: "to",
			type: "string",
		},
		{
			name: "cc",
			baseName: "cc",
			type: "string",
		},
		{
			name: "bcc",
			baseName: "bcc",
			type: "string",
		},
		{
			name: "sender",
			baseName: "sender",
			type: "string",
		},
		{
			name: "replyTo",
			baseName: "replyTo",
			type: "string",
		},
		{
			name: "subject",
			baseName: "subject",
			type: "string",
		},
		{
			name: "text",
			baseName: "text",
			type: "string",
		},
		{
			name: "html",
			baseName: "html",
			type: "string",
		},
		{
			name: "priority",
			baseName: "priority",
			type: "string",
		},
		{
			name: "attachments",
			baseName: "attachments",
			type: "Array<any>",
		},
	];

	static getAttributeTypeMap() {
		return EmailRequest.attributeTypeMap;
	}
}

export class Fare {
	"currency"?: string;
	"text"?: string;
	"value"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "currency",
			baseName: "currency",
			type: "string",
		},
		{
			name: "text",
			baseName: "text",
			type: "string",
		},
		{
			name: "value",
			baseName: "value",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return Fare.attributeTypeMap;
	}
}

/**
 * Represent a free ride response
 */
export class FreeRide {
	/**
	 * The number of used free rides
	 */
	"value"?: number;
	/**
	 * The number of remaining free rides
	 */
	"available"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "value",
			baseName: "value",
			type: "number",
		},
		{
			name: "available",
			baseName: "available",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return FreeRide.attributeTypeMap;
	}
}

/**
 * Represent an available free rides response
 */
export class FreeRidesAvailable {
	/**
	 * The number of remaining free rides
	 */
	"numberAvailable"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "numberAvailable",
			baseName: "numberAvailable",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return FreeRidesAvailable.attributeTypeMap;
	}
}

/**
 * Represent a free ride for travel request
 */
export class FreeRidesForTravelRequest {
	/**
	 * The number of given free rides
	 */
	"units"?: number;
	/**
	 * The reason for giving free rides
	 */
	"reason"?: string;
	/**
	 * The id of user given free rides
	 */
	"userId"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "units",
			baseName: "units",
			type: "number",
		},
		{
			name: "reason",
			baseName: "reason",
			type: "string",
		},
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return FreeRidesForTravelRequest.attributeTypeMap;
	}
}

/**
 * Represent a free ride request
 */
export class FreeRidesRequest {
	/**
	 * The number of given free rides
	 */
	"units"?: number;
	/**
	 * The reason for giving free rides
	 */
	"reason"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "units",
			baseName: "units",
			type: "number",
		},
		{
			name: "reason",
			baseName: "reason",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return FreeRidesRequest.attributeTypeMap;
	}
}

export class GeocodedWaypoint {
	"geocoderStatus"?: string;
	"placeId"?: string;
	"types"?: Array<string>;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "geocoderStatus",
			baseName: "geocoder_status",
			type: "string",
		},
		{
			name: "placeId",
			baseName: "place_id",
			type: "string",
		},
		{
			name: "types",
			baseName: "types",
			type: "Array<string>",
		},
	];

	static getAttributeTypeMap() {
		return GeocodedWaypoint.attributeTypeMap;
	}
}

export class GetUserFailedResponse {
	"errors"?: Array<string>;
	"type"?: string;
	"title"?: string;
	"status"?: string;
	"userProfile"?: UserProfileResponse;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "errors",
			baseName: "errors",
			type: "Array<string>",
		},
		{
			name: "type",
			baseName: "type",
			type: "string",
		},
		{
			name: "title",
			baseName: "title",
			type: "string",
		},
		{
			name: "status",
			baseName: "status",
			type: "string",
		},
		{
			name: "userProfile",
			baseName: "userProfile",
			type: "UserProfileResponse",
		},
	];

	static getAttributeTypeMap() {
		return GetUserFailedResponse.attributeTypeMap;
	}
}

export class GtfsRestrictionModel {
	"code"?: GtfsRestrictionModel.CodeEnum;
	"description"?: string;
	"details"?: any;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "code",
			baseName: "code",
			type: "GtfsRestrictionModel.CodeEnum",
		},
		{
			name: "description",
			baseName: "description",
			type: "string",
		},
		{
			name: "details",
			baseName: "details",
			type: "any",
		},
	];

	static getAttributeTypeMap() {
		return GtfsRestrictionModel.attributeTypeMap;
	}
}

export namespace GtfsRestrictionModel {
	export enum CodeEnum {
		None = <any>"none",
		InternalError = <any>"internal_error",
		NotFound = <any>"not_found",
		NoStops = <any>"no_stops",
		NotUnique = <any>"not_unique",
		NotInCalendar = <any>"not_in_calendar",
		NotInDate = <any>"not_in_date",
		NotInDay = <any>"not_in_day",
		StopsNotInTrip = <any>"stops_not_in_trip",
		StopsNotInorder = <any>"stops_not_inorder",
	}
}
export class InvoiceDataResponse {
	/**
	 * The date when the payment was created
	 */
	"createdOn"?: number;
	/**
	 * The date when the payment was cleared
	 */
	"clearedOn"?: number;
	/**
	 * The payment Id
	 */
	"id"?: string;
	/**
	 * The user Id
	 */
	"userId"?: string;
	/**
	 * The user's email.
	 */
	"userMail"?: string;
	/**
	 * The user's phone
	 */
	"userPhone"?: string;
	/**
	 * The user full name
	 */
	"userFullName"?: string;
	/**
	 * The type of the payment purpose
	 */
	"purposeType"?: InvoiceDataResponse.PurposeTypeEnum;
	/**
	 * The description about the payment
	 */
	"descriptionLines"?: Array<PaymentDescriptionQuote>;
	/**
	 * The amount of ILS payed
	 */
	"price"?: number;
	/**
	 * The last four digits of the credit card
	 */
	"creditcardHint"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "createdOn",
			baseName: "createdOn",
			type: "number",
		},
		{
			name: "clearedOn",
			baseName: "clearedOn",
			type: "number",
		},
		{
			name: "id",
			baseName: "id",
			type: "string",
		},
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
		{
			name: "userMail",
			baseName: "userMail",
			type: "string",
		},
		{
			name: "userPhone",
			baseName: "userPhone",
			type: "string",
		},
		{
			name: "userFullName",
			baseName: "userFullName",
			type: "string",
		},
		{
			name: "purposeType",
			baseName: "purposeType",
			type: "InvoiceDataResponse.PurposeTypeEnum",
		},
		{
			name: "descriptionLines",
			baseName: "descriptionLines",
			type: "Array<PaymentDescriptionQuote>",
		},
		{
			name: "price",
			baseName: "price",
			type: "number",
		},
		{
			name: "creditcardHint",
			baseName: "creditcardHint",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return InvoiceDataResponse.attributeTypeMap;
	}
}

export namespace InvoiceDataResponse {
	export enum PurposeTypeEnum {
		None = <any>"none",
		Travel = <any>"travel",
		RefundMissedTravels = <any>"refundMissedTravels",
		Compensation = <any>"compensation",
		TravelCard = <any>"travelCard",
		Payment = <any>"payment",
	}
}
export class Leg {
	"arrivalTime"?: StopTimeModel;
	"departureTime"?: StopTimeModel;
	"distance"?: Distance;
	"duration"?: Duration;
	"endAddress"?: string;
	"endLocation"?: Location;
	"startAddress"?: string;
	"startLocation"?: Location;
	"steps"?: Array<TransitStep>;
	"trafficSpeedEntry"?: Array<any>;
	"viaWaypoint"?: Array<any>;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "arrivalTime",
			baseName: "arrival_time",
			type: "StopTimeModel",
		},
		{
			name: "departureTime",
			baseName: "departure_time",
			type: "StopTimeModel",
		},
		{
			name: "distance",
			baseName: "distance",
			type: "Distance",
		},
		{
			name: "duration",
			baseName: "duration",
			type: "Duration",
		},
		{
			name: "endAddress",
			baseName: "end_address",
			type: "string",
		},
		{
			name: "endLocation",
			baseName: "end_location",
			type: "Location",
		},
		{
			name: "startAddress",
			baseName: "start_address",
			type: "string",
		},
		{
			name: "startLocation",
			baseName: "start_location",
			type: "Location",
		},
		{
			name: "steps",
			baseName: "steps",
			type: "Array<TransitStep>",
		},
		{
			name: "trafficSpeedEntry",
			baseName: "traffic_speed_entry",
			type: "Array<any>",
		},
		{
			name: "viaWaypoint",
			baseName: "via_waypoint",
			type: "Array<any>",
		},
	];

	static getAttributeTypeMap() {
		return Leg.attributeTypeMap;
	}
}

export class Location {
	"lat"?: number;
	"lng"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "lat",
			baseName: "lat",
			type: "number",
		},
		{
			name: "lng",
			baseName: "lng",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return Location.attributeTypeMap;
	}
}

export class ModelError {
	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [];

	static getAttributeTypeMap() {
		return ModelError.attributeTypeMap;
	}
}

export class OverviewPolyline {
	"points"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "points",
			baseName: "points",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return OverviewPolyline.attributeTypeMap;
	}
}

export class PayUsingTravelCardRequest {
	/**
	 * The number of tickets to punch.
	 */
	"numberOfTickets"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "numberOfTickets",
			baseName: "numberOfTickets",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return PayUsingTravelCardRequest.attributeTypeMap;
	}
}

/**
 * Represents a payment request.
 */
export class PaymentDescriptionQuote {
	/**
	 * The quote that identify the message
	 */
	"quote"?: PaymentDescriptionQuote.QuoteEnum;
	/**
	 * The message
	 */
	"message"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "quote",
			baseName: "quote",
			type: "PaymentDescriptionQuote.QuoteEnum",
		},
		{
			name: "message",
			baseName: "message",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return PaymentDescriptionQuote.attributeTypeMap;
	}
}

export namespace PaymentDescriptionQuote {
	export enum QuoteEnum {
		Date = <any>"date",
		Name = <any>"name",
		Tag = <any>"tag",
		Refund = <any>"refund",
		Purpose = <any>"purpose",
		Factors = <any>"factors",
		Units = <any>"units",
	}
}
/**
 * Represent the non secured information about the payment-method
 */
export class PaymentMethodInfo {
	/**
	 * The expiration Month.
	 */
	"expirationMonth"?: number;
	/**
	 * The expiration Year.
	 */
	"expirationYear"?: number;
	/**
	 * The 4 last digits of the payment method as hint for verification.
	 */
	"hint"?: string;
	/**
	 * The status of the payment method
	 */
	"status"?: PaymentMethodInfo.StatusEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "expirationMonth",
			baseName: "expirationMonth",
			type: "number",
		},
		{
			name: "expirationYear",
			baseName: "expirationYear",
			type: "number",
		},
		{
			name: "hint",
			baseName: "hint",
			type: "string",
		},
		{
			name: "status",
			baseName: "status",
			type: "PaymentMethodInfo.StatusEnum",
		},
	];

	static getAttributeTypeMap() {
		return PaymentMethodInfo.attributeTypeMap;
	}
}

export namespace PaymentMethodInfo {
	export enum StatusEnum {
		None = <any>"none",
		Pending = <any>"pending",
		Active = <any>"active",
		Blocked = <any>"blocked",
		Expired = <any>"expired",
	}
}
/**
 * Represent a payment method token
 */
export class PaymentMethodRequest {
	/**
	 * Represent the payment method token. This token is created by a third-party (CreditGuard) and is required for the clearance procedure.
	 */
	"token"?: string;
	/**
	 * Represent the payment method non secured info.
	 */
	"info"?: PaymentMethodInfo;
	/**
	 * The name of the payment method provider. In our case \"CreditGurd\"
	 */
	"providerName"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "token",
			baseName: "token",
			type: "string",
		},
		{
			name: "info",
			baseName: "info",
			type: "PaymentMethodInfo",
		},
		{
			name: "providerName",
			baseName: "providerName",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return PaymentMethodRequest.attributeTypeMap;
	}
}

export class PaymentResponse {
	/**
	 * The payment Id
	 */
	"id"?: string;
	/**
	 * The Id of this payment
	 */
	"paymentId"?: string;
	/**
	 * The Id of user that made this payment
	 */
	"userId"?: string;
	/**
	 * The type of payment-method used for this payment
	 */
	"paymentMethod"?: PaymentResponse.PaymentMethodEnum;
	/**
	 * The Id of the specific payment method used for this payment
	 */
	"paymentMethodId"?: string;
	/**
	 * The purpose of the payment
	 */
	"purposeType"?: PaymentResponse.PurposeTypeEnum;
	/**
	 * The Id of the purpose item that is payed
	 */
	"purposeId"?: string;
	/**
	 * The number of units that was payed
	 */
	"units"?: number;
	/**
	 * The amount of ILS payed
	 */
	"price"?: number;
	/**
	 * The date when the payment was created
	 */
	"createdOn"?: number;
	/**
	 * The date when the payment was cleared
	 */
	"clearedOn"?: number;
	/**
	 * Was this payment successful
	 */
	"isSuccess"?: boolean;
	/**
	 * The Id of the corelating payment
	 */
	"corelationId"?: string;
	/**
	 * The Id of the authorization for this payment
	 */
	"authorizationId"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "id",
			baseName: "_id",
			type: "string",
		},
		{
			name: "paymentId",
			baseName: "paymentId",
			type: "string",
		},
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
		{
			name: "paymentMethod",
			baseName: "paymentMethod",
			type: "PaymentResponse.PaymentMethodEnum",
		},
		{
			name: "paymentMethodId",
			baseName: "paymentMethodId",
			type: "string",
		},
		{
			name: "purposeType",
			baseName: "purposeType",
			type: "PaymentResponse.PurposeTypeEnum",
		},
		{
			name: "purposeId",
			baseName: "purposeId",
			type: "string",
		},
		{
			name: "units",
			baseName: "units",
			type: "number",
		},
		{
			name: "price",
			baseName: "price",
			type: "number",
		},
		{
			name: "createdOn",
			baseName: "createdOn",
			type: "number",
		},
		{
			name: "clearedOn",
			baseName: "clearedOn",
			type: "number",
		},
		{
			name: "isSuccess",
			baseName: "isSuccess",
			type: "boolean",
		},
		{
			name: "corelationId",
			baseName: "corelationId",
			type: "string",
		},
		{
			name: "authorizationId",
			baseName: "authorizationId",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return PaymentResponse.attributeTypeMap;
	}
}

export namespace PaymentResponse {
	export enum PaymentMethodEnum {
		None = <any>"none",
		TravelCard = <any>"travelCard",
		CreditCard = <any>"creditCard",
		Compensation = <any>"compensation",
		J4 = <any>"J4",
		J5 = <any>"J5",
	}
	export enum PurposeTypeEnum {
		None = <any>"none",
		Travel = <any>"travel",
		RefundMissedTravels = <any>"refundMissedTravels",
		Compensation = <any>"compensation",
		TravelCard = <any>"travelCard",
		Payment = <any>"payment",
	}
}
/**
 * Represents a payment request.
 */
export class PushNotificationSubscribeRequest {
	/**
	 * The Token of the device
	 */
	"deviceToken"?: string;
	/**
	 * The mobile platform type
	 */
	"platformType"?: PushNotificationSubscribeRequest.PlatformTypeEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "deviceToken",
			baseName: "deviceToken",
			type: "string",
		},
		{
			name: "platformType",
			baseName: "platformType",
			type: "PushNotificationSubscribeRequest.PlatformTypeEnum",
		},
	];

	static getAttributeTypeMap() {
		return PushNotificationSubscribeRequest.attributeTypeMap;
	}
}

export namespace PushNotificationSubscribeRequest {
	export enum PlatformTypeEnum {
		Android = <any>"android",
		Ios = <any>"ios",
	}
}
export class RefundDelayedCanclationFactorsListUpdateRequest {
	"refundFactorFrames"?: Array<RefundDelayedCanclationTimeFrame>;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "refundFactorFrames",
			baseName: "refundFactorFrames",
			type: "Array<RefundDelayedCanclationTimeFrame>",
		},
	];

	static getAttributeTypeMap() {
		return RefundDelayedCanclationFactorsListUpdateRequest.attributeTypeMap;
	}
}

export class RefundDelayedCanclationTimeFrame {
	"factor"?: number;
	"delayMinutes"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "factor",
			baseName: "factor",
			type: "number",
		},
		{
			name: "delayMinutes",
			baseName: "delayMinutes",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return RefundDelayedCanclationTimeFrame.attributeTypeMap;
	}
}

/**
 * Represents the reserved line record
 */
export class ReservedPlaceLineResponse {
	/**
	 * The reserved line id
	 */
	"id"?: string;
	/**
	 * The reserved line name
	 */
	"name"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "id",
			baseName: "id",
			type: "string",
		},
		{
			name: "name",
			baseName: "name",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return ReservedPlaceLineResponse.attributeTypeMap;
	}
}

export class Route {
	"bounds"?: Bounds;
	"copyrights"?: string;
	"legs"?: Array<Leg>;
	"overviewPolyline"?: OverviewPolyline;
	"summary"?: string;
	"warnings"?: Array<string>;
	"waypointOrder"?: Array<string>;
	"fare"?: Fare;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "bounds",
			baseName: "bounds",
			type: "Bounds",
		},
		{
			name: "copyrights",
			baseName: "copyrights",
			type: "string",
		},
		{
			name: "legs",
			baseName: "legs",
			type: "Array<Leg>",
		},
		{
			name: "overviewPolyline",
			baseName: "overview_polyline",
			type: "OverviewPolyline",
		},
		{
			name: "summary",
			baseName: "summary",
			type: "string",
		},
		{
			name: "warnings",
			baseName: "warnings",
			type: "Array<string>",
		},
		{
			name: "waypointOrder",
			baseName: "waypoint_order",
			type: "Array<string>",
		},
		{
			name: "fare",
			baseName: "fare",
			type: "Fare",
		},
	];

	static getAttributeTypeMap() {
		return Route.attributeTypeMap;
	}
}

export class RouteOptionsResponse {
	"error"?: Error;
	"data"?: Data;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "error",
			baseName: "error",
			type: "Error",
		},
		{
			name: "data",
			baseName: "data",
			type: "Data",
		},
	];

	static getAttributeTypeMap() {
		return RouteOptionsResponse.attributeTypeMap;
	}
}

/**
 * Represent a stop on a route
 */
export class RouteStop {
	/**
	 * The stop id
	 */
	"stopId"?: string;
	/**
	 * The stop name
	 */
	"stopName"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "stopId",
			baseName: "stopId",
			type: "string",
		},
		{
			name: "stopName",
			baseName: "stopName",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return RouteStop.attributeTypeMap;
	}
}

/**
 * Represent a stop on a route
 */
export class RouteStopTime {
	/**
	 * The unix time of a stop
	 */
	"time"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "time",
			baseName: "time",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return RouteStopTime.attributeTypeMap;
	}
}

/**
 * Represent the register verification request
 */
export class SMSLoginRequest {
	/**
	 * The phone number to use for the registration
	 */
	"phoneNumber"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "phoneNumber",
			baseName: "phoneNumber",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return SMSLoginRequest.attributeTypeMap;
	}
}

/**
 * Represent the Login response
 */
export class SMSLoginResponse {
	/**
	 * Represent the status of the SMS with the verification-code that need to be sent to the user.
	 */
	"smsSendStatus"?: SMSLoginResponse.SmsSendStatusEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "smsSendStatus",
			baseName: "smsSendStatus",
			type: "SMSLoginResponse.SmsSendStatusEnum",
		},
	];

	static getAttributeTypeMap() {
		return SMSLoginResponse.attributeTypeMap;
	}
}

export namespace SMSLoginResponse {
	export enum SmsSendStatusEnum {
		None = <any>"none",
		Sentok = <any>"sentok",
		Invalidnumber = <any>"invalidnumber",
		Sentfailed = <any>"sentfailed",
	}
}
/**
 * Represent the login verification request
 */
export class SMSLoginVerificationRequest {
	/**
	 * The phone number used for the registration
	 */
	"phoneNumber"?: string;
	/**
	 * The verification code sent to the user in SMS
	 */
	"verificationCode"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "phoneNumber",
			baseName: "phoneNumber",
			type: "string",
		},
		{
			name: "verificationCode",
			baseName: "verificationCode",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return SMSLoginVerificationRequest.attributeTypeMap;
	}
}

/**
 * Represents an SMS request.
 */
export class SMSRequest {
	/**
	 * The SMS message
	 */
	"messageText"?: string;
	/**
	 * Phone number to receive SMS
	 */
	"phoneNumbers"?: Array<string>;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "messageText",
			baseName: "messageText",
			type: "string",
		},
		{
			name: "phoneNumbers",
			baseName: "phoneNumbers",
			type: "Array<string>",
		},
	];

	static getAttributeTypeMap() {
		return SMSRequest.attributeTypeMap;
	}
}

/**
 * Represent claim for senior-citizenship
 */
export class SeniorCitizenshipClaim {
	/**
	 * The status of the user's claim for senior-citizenship
	 */
	"claim"?: SeniorCitizenshipClaim.ClaimEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "claim",
			baseName: "claim",
			type: "SeniorCitizenshipClaim.ClaimEnum",
		},
	];

	static getAttributeTypeMap() {
		return SeniorCitizenshipClaim.attributeTypeMap;
	}
}

export namespace SeniorCitizenshipClaim {
	export enum ClaimEnum {
		None = <any>"none",
		Claiming = <any>"claiming",
		Confirmed = <any>"confirmed",
		Rejected = <any>"rejected",
	}
}
export class SpecificVehicle {
	/**
	 * Specifies the vehicle headSign
	 */
	"headSign"?: string;
	/**
	 * Specifies the vehicle license plate.
	 */
	"licensePlate"?: string;
	/**
	 * Specifies the vehicle type
	 */
	"type"?: SpecificVehicle.TypeEnum;
	/**
	 * Specifies the number of seats available in the vehicle
	 */
	"numberOfSeats"?: number;
	/**
	 * Specifies the driver's name
	 */
	"driverName"?: string;
	/**
	 * Specifies the vehicle location as a comma separated lat,lng
	 */
	"location"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "headSign",
			baseName: "headSign",
			type: "string",
		},
		{
			name: "licensePlate",
			baseName: "licensePlate",
			type: "string",
		},
		{
			name: "type",
			baseName: "type",
			type: "SpecificVehicle.TypeEnum",
		},
		{
			name: "numberOfSeats",
			baseName: "numberOfSeats",
			type: "number",
		},
		{
			name: "driverName",
			baseName: "driverName",
			type: "string",
		},
		{
			name: "location",
			baseName: "location",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return SpecificVehicle.attributeTypeMap;
	}
}

export namespace SpecificVehicle {
	export enum TypeEnum {
		None = <any>"none",
		Accessible = <any>"accessible",
		Bus = <any>"bus",
		Minibus = <any>"minibus",
		Car = <any>"car",
	}
}
export class StopTimeModel {
	"text"?: string;
	"timeZone"?: string;
	"value"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "text",
			baseName: "text",
			type: "string",
		},
		{
			name: "timeZone",
			baseName: "time_zone",
			type: "string",
		},
		{
			name: "value",
			baseName: "value",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return StopTimeModel.attributeTypeMap;
	}
}

export class TextCatalogLine {
	/**
	 * The identifier of the text
	 */
	"textCode"?: string;
	/**
	 * The other identifier can be used for example to describe different representations of the text such as 'short' or 'long' text
	 */
	"fieldCode"?: string;
	/**
	 * Specifies actual text value
	 */
	"text"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "textCode",
			baseName: "textCode",
			type: "string",
		},
		{
			name: "fieldCode",
			baseName: "fieldCode",
			type: "string",
		},
		{
			name: "text",
			baseName: "text",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return TextCatalogLine.attributeTypeMap;
	}
}

export class TicketListPriceModel {
	"seniorCitizenshipStatus"?: TicketListPriceModel.SeniorCitizenshipStatusEnum;
	"priceFrames"?: Array<TicketPriceTimeFrame>;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "seniorCitizenshipStatus",
			baseName: "seniorCitizenshipStatus",
			type: "TicketListPriceModel.SeniorCitizenshipStatusEnum",
		},
		{
			name: "priceFrames",
			baseName: "priceFrames",
			type: "Array<TicketPriceTimeFrame>",
		},
	];

	static getAttributeTypeMap() {
		return TicketListPriceModel.attributeTypeMap;
	}
}

export namespace TicketListPriceModel {
	export enum SeniorCitizenshipStatusEnum {
		None = <any>"none",
		Claiming = <any>"claiming",
		Confirmed = <any>"confirmed",
		Rejected = <any>"rejected",
	}
}
export class TicketPriceTimeFrame {
	"price"?: number;
	"priceOnLowDemand"?: number;
	"demandRatio"?: number;
	"startTimeOfDay"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "price",
			baseName: "price",
			type: "number",
		},
		{
			name: "priceOnLowDemand",
			baseName: "priceOnLowDemand",
			type: "number",
		},
		{
			name: "demandRatio",
			baseName: "demandRatio",
			type: "number",
		},
		{
			name: "startTimeOfDay",
			baseName: "startTimeOfDay",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return TicketPriceTimeFrame.attributeTypeMap;
	}
}

export class TicketRefundCreditFactorsListUpdateRequest {
	"refundFactorFrames"?: Array<TicketRefundCreditFrame>;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "refundFactorFrames",
			baseName: "refundFactorFrames",
			type: "Array<TicketRefundCreditFrame>",
		},
	];

	static getAttributeTypeMap() {
		return TicketRefundCreditFactorsListUpdateRequest.attributeTypeMap;
	}
}

export class TicketRefundCreditFrame {
	"factor"?: number;
	"missedTravels"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "factor",
			baseName: "factor",
			type: "number",
		},
		{
			name: "missedTravels",
			baseName: "missedTravels",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return TicketRefundCreditFrame.attributeTypeMap;
	}
}

export class TransitStep {
	"tripId"?: string;
	"restrictions"?: GtfsRestrictionModel;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "tripId",
			baseName: "trip_id",
			type: "string",
		},
		{
			name: "restrictions",
			baseName: "restrictions",
			type: "GtfsRestrictionModel",
		},
	];

	static getAttributeTypeMap() {
		return TransitStep.attributeTypeMap;
	}
}

/**
 * Represents the travel of the user that includes the TravelRide, the part of the travel that is provided by the PQ providers
 */
export class Travel {
	/**
	 * Represents location of the travel origin as comma separated lat,lng
	 */
	"origin"?: string;
	/**
	 * Represents location of the travel destination as comma separated lat,lng
	 */
	"destination"?: string;
	/**
	 * Represents the pickup stop of the travel
	 */
	"pickupStop"?: TravelStop;
	/**
	 * Represents the drop-off stop of the travel
	 */
	"dropoffStop"?: TravelStop;
	/**
	 * The vehicle in the option.
	 */
	"vehicle"?: SpecificVehicle;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "origin",
			baseName: "origin",
			type: "string",
		},
		{
			name: "destination",
			baseName: "destination",
			type: "string",
		},
		{
			name: "pickupStop",
			baseName: "pickupStop",
			type: "TravelStop",
		},
		{
			name: "dropoffStop",
			baseName: "dropoffStop",
			type: "TravelStop",
		},
		{
			name: "vehicle",
			baseName: "vehicle",
			type: "SpecificVehicle",
		},
	];

	static getAttributeTypeMap() {
		return Travel.attributeTypeMap;
	}
}

/**
 * Represent the information about a specific travel request.
 */
export class TravelBookRequest {
	/**
	 * Represents the id of the travel option that was chosen for the travel
	 */
	"requestId"?: string;
	/**
	 * The payment method to use for the payment
	 */
	"paymentMethod"?: TravelBookRequest.PaymentMethodEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "requestId",
			baseName: "requestId",
			type: "string",
		},
		{
			name: "paymentMethod",
			baseName: "paymentMethod",
			type: "TravelBookRequest.PaymentMethodEnum",
		},
	];

	static getAttributeTypeMap() {
		return TravelBookRequest.attributeTypeMap;
	}
}

export namespace TravelBookRequest {
	export enum PaymentMethodEnum {
		None = <any>"none",
		TravelCard = <any>"travelCard",
		CreditCard = <any>"creditCard",
		Compensation = <any>"compensation",
		J4 = <any>"J4",
		J5 = <any>"J5",
	}
}
export class TravelCancellationCostResponse {
	/**
	 * Represent the payment type
	 */
	"paymentType"?: TravelCancellationCostResponse.PaymentTypeEnum;
	/**
	 * Represent the payment amount (punches when using travel-card, NIS otherwise)
	 */
	"amount"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "paymentType",
			baseName: "paymentType",
			type: "TravelCancellationCostResponse.PaymentTypeEnum",
		},
		{
			name: "amount",
			baseName: "amount",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return TravelCancellationCostResponse.attributeTypeMap;
	}
}

export namespace TravelCancellationCostResponse {
	export enum PaymentTypeEnum {
		None = <any>"none",
		TravelCard = <any>"travelCard",
		CreditCard = <any>"creditCard",
		Compensation = <any>"compensation",
		J4 = <any>"J4",
		J5 = <any>"J5",
	}
}
export class TravelCardListPriceRequest {
	"price"?: number;
	"numberOfTickets"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "price",
			baseName: "price",
			type: "number",
		},
		{
			name: "numberOfTickets",
			baseName: "numberOfTickets",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return TravelCardListPriceRequest.attributeTypeMap;
	}
}

/**
 * Represent the token enrichment parameters
 */
export class TravelCardOfferResponse {
	/**
	 * The number of tickets in the travel-card
	 */
	"value"?: number;
	/**
	 * The price of the travel-card in ILS
	 */
	"price"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "value",
			baseName: "value",
			type: "number",
		},
		{
			name: "price",
			baseName: "price",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return TravelCardOfferResponse.attributeTypeMap;
	}
}

/**
 * Represent a payment method token
 */
export class TravelCardRequest {
	/**
	 * Represent the number of tickets in the card.
	 */
	"value"?: number;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "value",
			baseName: "value",
			type: "number",
		},
	];

	static getAttributeTypeMap() {
		return TravelCardRequest.attributeTypeMap;
	}
}

/**
 * Represent the travel-card details
 */
export class TravelCardResponse {
	/**
	 * Represent the id of travel-card.
	 */
	"cardId"?: string;
	/**
	 * Represent the amount of ILS payed for the travel-card.
	 */
	"price"?: number;
	/**
	 * Represent the number of tickets in the card.
	 */
	"value"?: number;
	/**
	 * Represent the number of tickets remained in the card.
	 */
	"available"?: number;
	/**
	 * Represent the purchase code for the card.
	 */
	"purchaseCode"?: string;
	/**
	 * Represent the purchase date for the card.
	 */
	"purchaseDate"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "cardId",
			baseName: "cardId",
			type: "string",
		},
		{
			name: "price",
			baseName: "price",
			type: "number",
		},
		{
			name: "value",
			baseName: "value",
			type: "number",
		},
		{
			name: "available",
			baseName: "available",
			type: "number",
		},
		{
			name: "purchaseCode",
			baseName: "purchaseCode",
			type: "string",
		},
		{
			name: "purchaseDate",
			baseName: "purchaseDate",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return TravelCardResponse.attributeTypeMap;
	}
}

/**
 * Represents the user feedback for a trip
 */
export class TravelFeedback {
	/**
	 * Represents the feedback creation date
	 */
	"createDate"?: number;
	/**
	 * Represents the feedback update date
	 */
	"updatedDate"?: number;
	/**
	 * User Id
	 */
	"createdBy"?: string;
	/**
	 * The id of the travel that is rated
	 */
	"travelId"?: string;
	/**
	 * A number between 1 to 5 representing the rate
	 */
	"rate"?: number;
	/**
	 * A list of reasons related to the rate value
	 */
	"reasons"?: Array<string>;
	/**
	 * A free text provided by the user to describe the travel rate
	 */
	"comment"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "createDate",
			baseName: "createDate",
			type: "number",
		},
		{
			name: "updatedDate",
			baseName: "updatedDate",
			type: "number",
		},
		{
			name: "createdBy",
			baseName: "createdBy",
			type: "string",
		},
		{
			name: "travelId",
			baseName: "travelId",
			type: "string",
		},
		{
			name: "rate",
			baseName: "rate",
			type: "number",
		},
		{
			name: "reasons",
			baseName: "reasons",
			type: "Array<string>",
		},
		{
			name: "comment",
			baseName: "comment",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return TravelFeedback.attributeTypeMap;
	}
}

/**
 * Represents the user feedback for a trip
 */
export class TravelFeedbackRequest {
	/**
	 * The id of the travel that is rated
	 */
	"travelId"?: string;
	/**
	 * A number between 1 to 5 representing the rate
	 */
	"rate"?: number;
	/**
	 * A list of reasons related to the rate value
	 */
	"reasons"?: Array<string>;
	/**
	 * A free text provided by the user to describe the travel rate
	 */
	"comment"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "travelId",
			baseName: "travelId",
			type: "string",
		},
		{
			name: "rate",
			baseName: "rate",
			type: "number",
		},
		{
			name: "reasons",
			baseName: "reasons",
			type: "Array<string>",
		},
		{
			name: "comment",
			baseName: "comment",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return TravelFeedbackRequest.attributeTypeMap;
	}
}

/**
 * Represent the information about a specific travel.
 */
export class TravelHistoryResponse {
	/**
	 * Represents the user id (the traveler)
	 */
	"userId"?: string;
	/**
	 * Represent the unix time when the travel was started
	 */
	"startedOn"?: number;
	/**
	 * Represent the unix time when the state was ended
	 */
	"endedOn"?: number;
	/**
	 * The id of the travel that was created.
	 */
	"travelId"?: string;
	/**
	 * Represents the route option used for the travel
	 */
	"travelDetails"?: Travel;
	/**
	 * Represents the status of the travel
	 */
	"travelState"?: TravelHistoryResponse.TravelStateEnum;
	/**
	 * The type of payment-method used for this payment
	 */
	"payedUsing"?: TravelHistoryResponse.PayedUsingEnum;
	/**
	 * The identifier of the payment method
	 */
	"cardId"?: string;
	/**
	 * The number of units that was payed
	 */
	"payedUnits"?: number;
	/**
	 * The amount of ILS payed
	 */
	"payedPrice"?: number;
	/**
	 * A number between 1 to 5 representing the rate
	 */
	"feedbackRate"?: number;
	/**
	 * A free text provided by the user to describe the travel rate
	 */
	"feedbackComment"?: string;
	/**
	 * A list of reasons related to the rate value
	 */
	"feedbackReasons"?: Array<string>;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
		{
			name: "startedOn",
			baseName: "startedOn",
			type: "number",
		},
		{
			name: "endedOn",
			baseName: "endedOn",
			type: "number",
		},
		{
			name: "travelId",
			baseName: "travelId",
			type: "string",
		},
		{
			name: "travelDetails",
			baseName: "travelDetails",
			type: "Travel",
		},
		{
			name: "travelState",
			baseName: "travelState",
			type: "TravelHistoryResponse.TravelStateEnum",
		},
		{
			name: "payedUsing",
			baseName: "payedUsing",
			type: "TravelHistoryResponse.PayedUsingEnum",
		},
		{
			name: "cardId",
			baseName: "cardId",
			type: "string",
		},
		{
			name: "payedUnits",
			baseName: "payedUnits",
			type: "number",
		},
		{
			name: "payedPrice",
			baseName: "payedPrice",
			type: "number",
		},
		{
			name: "feedbackRate",
			baseName: "feedbackRate",
			type: "number",
		},
		{
			name: "feedbackComment",
			baseName: "feedbackComment",
			type: "string",
		},
		{
			name: "feedbackReasons",
			baseName: "feedbackReasons",
			type: "Array<string>",
		},
	];

	static getAttributeTypeMap() {
		return TravelHistoryResponse.attributeTypeMap;
	}
}

export namespace TravelHistoryResponse {
	export enum TravelStateEnum {
		None = <any>"none",
		Assigned = <any>"assigned",
		Pending = <any>"pending",
		NotAvailable = <any>"notAvailable",
		NoShow = <any>"noShow",
		Arrived = <any>"arrived",
		Bordered = <any>"bordered",
		Finished = <any>"finished",
		Canceled = <any>"canceled",
	}
	export enum PayedUsingEnum {
		None = <any>"none",
		TravelCard = <any>"travelCard",
		CreditCard = <any>"creditCard",
		Compensation = <any>"compensation",
		J4 = <any>"J4",
		J5 = <any>"J5",
	}
}
export class TravelOptionResponse {
	/**
	 * Represents the availability of the option for booking.
	 */
	"validForBooking"?: boolean;
	/**
	 * Represents the expiration time for this option in seconds, -1 if expired and cannot be refreshed.
	 */
	"expiration"?: number;
	/**
	 * Represents the price in NIS of the option when using the travel-card
	 */
	"travelCardPrice"?: number;
	/**
	 * Represents the number of NIS price of the travel
	 */
	"creditCardPrice"?: number;
	/**
	 * Represents the number of free rides the user can use for this travel
	 */
	"freeRides"?: number;
	/**
	 * Represents the number of NIS price of the travel
	 */
	"status"?: TravelOptionResponse.StatusEnum;
	/**
	 * Represents location of the travel origin as comma separated lat,lng
	 */
	"origin"?: string;
	/**
	 * Represents location of the travel destination as comma separated lat,lng
	 */
	"destination"?: string;
	/**
	 * Represents the pickup stop of the travel
	 */
	"pickupStop"?: TravelStop;
	/**
	 * Represents the drop-off stop of the travel
	 */
	"dropoffStop"?: TravelStop;
	/**
	 * The vehicle in the option.
	 */
	"vehicle"?: SpecificVehicle;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "validForBooking",
			baseName: "validForBooking",
			type: "boolean",
		},
		{
			name: "expiration",
			baseName: "expiration",
			type: "number",
		},
		{
			name: "travelCardPrice",
			baseName: "travelCardPrice",
			type: "number",
		},
		{
			name: "creditCardPrice",
			baseName: "creditCardPrice",
			type: "number",
		},
		{
			name: "freeRides",
			baseName: "freeRides",
			type: "number",
		},
		{
			name: "status",
			baseName: "status",
			type: "TravelOptionResponse.StatusEnum",
		},
		{
			name: "origin",
			baseName: "origin",
			type: "string",
		},
		{
			name: "destination",
			baseName: "destination",
			type: "string",
		},
		{
			name: "pickupStop",
			baseName: "pickupStop",
			type: "TravelStop",
		},
		{
			name: "dropoffStop",
			baseName: "dropoffStop",
			type: "TravelStop",
		},
		{
			name: "vehicle",
			baseName: "vehicle",
			type: "SpecificVehicle",
		},
	];

	static getAttributeTypeMap() {
		return TravelOptionResponse.attributeTypeMap;
	}
}

export namespace TravelOptionResponse {
	export enum StatusEnum {
		OK = <any>"OK",
		NotInPolygon = <any>"NotInPolygon",
		OutOfServiceHours = <any>"OutOfServiceHours",
		OriginNearDestination = <any>"OriginNearDestination",
		NoMatchingStops = <any>"NoMatchingStops",
		IllegalOption = <any>"IllegalOption",
		ServiceInactiveError = <any>"ServiceInactiveError",
		NoAvailableVehicles = <any>"NoAvailableVehicles",
		NotInGradual = <any>"NotInGradual",
		WaitTooLong = <any>"WaitTooLong",
		TripUnavailable = <any>"TripUnavailable",
	}
}
export class TravelOptionState {
	/**
	 * The id of the user that have the option.
	 */
	"userId"?: string;
	/**
	 * Represents the updates for the travel option
	 */
	"updates"?: Array<TravelOptionResponse>;
	/**
	 * Represents the availability of the option for booking.
	 */
	"validForBooking"?: boolean;
	/**
	 * The provider name for this travel
	 */
	"provider"?: TravelOptionState.ProviderEnum;
	/**
	 * The provider id for this travel
	 */
	"providerId"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
		{
			name: "updates",
			baseName: "updates",
			type: "Array<TravelOptionResponse>",
		},
		{
			name: "validForBooking",
			baseName: "validForBooking",
			type: "boolean",
		},
		{
			name: "provider",
			baseName: "provider",
			type: "TravelOptionState.ProviderEnum",
		},
		{
			name: "providerId",
			baseName: "providerId",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return TravelOptionState.attributeTypeMap;
	}
}

export namespace TravelOptionState {
	export enum ProviderEnum {
		Via = <any>"via",
		Moovit = <any>"moovit",
	}
}
/**
 * Represent the information about a specific travel.
 */
export class TravelResponse {
	/**
	 * Represent the unix time when the travel was started
	 */
	"startedOn"?: number;
	/**
	 * Represent the unix time when the state was ended
	 */
	"endedOn"?: number;
	"userId"?: string;
	/**
	 * The id of the travel that was created.
	 */
	"travelId"?: string;
	/**
	 * Represents the route option used for the travel
	 */
	"details"?: Travel;
	/**
	 * Represents the Id of the payment made for the travel
	 */
	"paymentId"?: string;
	/**
	 * Represents the status of the travel
	 */
	"state"?: TravelResponse.StateEnum;
	"listPrice"?: number;
	/**
	 * Represents the travel provider.
	 */
	"provider"?: TravelResponse.ProviderEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "startedOn",
			baseName: "startedOn",
			type: "number",
		},
		{
			name: "endedOn",
			baseName: "endedOn",
			type: "number",
		},
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
		{
			name: "travelId",
			baseName: "travelId",
			type: "string",
		},
		{
			name: "details",
			baseName: "details",
			type: "Travel",
		},
		{
			name: "paymentId",
			baseName: "paymentId",
			type: "string",
		},
		{
			name: "state",
			baseName: "state",
			type: "TravelResponse.StateEnum",
		},
		{
			name: "listPrice",
			baseName: "listPrice",
			type: "number",
		},
		{
			name: "provider",
			baseName: "provider",
			type: "TravelResponse.ProviderEnum",
		},
	];

	static getAttributeTypeMap() {
		return TravelResponse.attributeTypeMap;
	}
}

export namespace TravelResponse {
	export enum StateEnum {
		None = <any>"none",
		Assigned = <any>"assigned",
		Pending = <any>"pending",
		NotAvailable = <any>"notAvailable",
		NoShow = <any>"noShow",
		Arrived = <any>"arrived",
		Bordered = <any>"bordered",
		Finished = <any>"finished",
		Canceled = <any>"canceled",
	}
	export enum ProviderEnum {
		Via = <any>"via",
		Moovit = <any>"moovit",
	}
}
/**
 * Represents part of the travel that is provided by the PQ providers
 */
export class TravelRide {
	/**
	 * Represents the pickup stop of the travel
	 */
	"pickupStop"?: TravelStop;
	/**
	 * Represents the drop-off stop of the travel
	 */
	"dropoffStop"?: TravelStop;
	/**
	 * The vehicle in the option.
	 */
	"vehicle"?: SpecificVehicle;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "pickupStop",
			baseName: "pickupStop",
			type: "TravelStop",
		},
		{
			name: "dropoffStop",
			baseName: "dropoffStop",
			type: "TravelStop",
		},
		{
			name: "vehicle",
			baseName: "vehicle",
			type: "SpecificVehicle",
		},
	];

	static getAttributeTypeMap() {
		return TravelRide.attributeTypeMap;
	}
}

export class TravelStateExternalRef {
	/**
	 * Represents the travel provider.
	 */
	"provider"?: TravelStateExternalRef.ProviderEnum;
	/**
	 * Represents the provider-travel provider-id
	 */
	"providerId"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "provider",
			baseName: "provider",
			type: "TravelStateExternalRef.ProviderEnum",
		},
		{
			name: "providerId",
			baseName: "providerId",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return TravelStateExternalRef.attributeTypeMap;
	}
}

export namespace TravelStateExternalRef {
	export enum ProviderEnum {
		Via = <any>"via",
		Moovit = <any>"moovit",
	}
}
export class TravelStateResponse {
	/**
	 * Represent the details of the travel
	 */
	"details"?: Travel;
	/**
	 * Represent the unix time when the travel was started
	 */
	"startedOn"?: number;
	/**
	 * Represent the unix time when the state was set
	 */
	"updatedOn"?: number;
	/**
	 * Represent the state of the travel
	 */
	"state"?: TravelStateResponse.StateEnum;
	/**
	 * Represent the previous state of the travel
	 */
	"previousStates"?: Array<TravelStateResponse.PreviousStatesEnum>;
	/**
	 * The id of the travel that was created.
	 */
	"travelId"?: string;
	"listPrice"?: number;
	/**
	 * Represents the travel provider.
	 */
	"provider"?: TravelStateResponse.ProviderEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "details",
			baseName: "details",
			type: "Travel",
		},
		{
			name: "startedOn",
			baseName: "startedOn",
			type: "number",
		},
		{
			name: "updatedOn",
			baseName: "updatedOn",
			type: "number",
		},
		{
			name: "state",
			baseName: "state",
			type: "TravelStateResponse.StateEnum",
		},
		{
			name: "previousStates",
			baseName: "previousStates",
			type: "Array<TravelStateResponse.PreviousStatesEnum>",
		},
		{
			name: "travelId",
			baseName: "travelId",
			type: "string",
		},
		{
			name: "listPrice",
			baseName: "listPrice",
			type: "number",
		},
		{
			name: "provider",
			baseName: "provider",
			type: "TravelStateResponse.ProviderEnum",
		},
	];

	static getAttributeTypeMap() {
		return TravelStateResponse.attributeTypeMap;
	}
}

export namespace TravelStateResponse {
	export enum StateEnum {
		None = <any>"none",
		Assigned = <any>"assigned",
		Pending = <any>"pending",
		NotAvailable = <any>"notAvailable",
		NoShow = <any>"noShow",
		Arrived = <any>"arrived",
		Bordered = <any>"bordered",
		Finished = <any>"finished",
		Canceled = <any>"canceled",
	}
	export enum PreviousStatesEnum {
		None = <any>"none",
		Assigned = <any>"assigned",
		Pending = <any>"pending",
		NotAvailable = <any>"notAvailable",
		NoShow = <any>"noShow",
		Arrived = <any>"arrived",
		Bordered = <any>"bordered",
		Finished = <any>"finished",
		Canceled = <any>"canceled",
	}
	export enum ProviderEnum {
		Via = <any>"via",
		Moovit = <any>"moovit",
	}
}
export class TravelStop {
	/**
	 * Represents the time to walk to the stop location in minutes
	 */
	"walkTime"?: number;
	/**
	 * Represents location of the stop as comma separated lat,lng
	 */
	"location"?: string;
	/**
	 * Represents the name of the stop
	 */
	"name"?: string;
	/**
	 * Represents the unix milliseconds time of the stop
	 */
	"time"?: number;
	/**
	 * Represents a quote about the stop time
	 */
	"timeQuote"?: TravelStop.TimeQuoteEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "walkTime",
			baseName: "walkTime",
			type: "number",
		},
		{
			name: "location",
			baseName: "location",
			type: "string",
		},
		{
			name: "name",
			baseName: "name",
			type: "string",
		},
		{
			name: "time",
			baseName: "time",
			type: "number",
		},
		{
			name: "timeQuote",
			baseName: "timeQuote",
			type: "TravelStop.TimeQuoteEnum",
		},
	];

	static getAttributeTypeMap() {
		return TravelStop.attributeTypeMap;
	}
}

export namespace TravelStop {
	export enum TimeQuoteEnum {
		None = <any>"none",
		AverageTime = <any>"averageTime",
		ETA = <any>"ETA",
	}
}
/**
 * Represent the user information that is returned to the provider.
 */
export class UserInfoResponse {
	/**
	 * Represents the unique user identity. This identity is created in any Registration
	 */
	"userId"?: string;
	/**
	 * Represents the first name of the user
	 */
	"firstName"?: string;
	/**
	 * Represents the last name of the user
	 */
	"lastName"?: string;
	/**
	 * Represents the phone number of the user
	 */
	"phoneNumber"?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
		{
			name: "firstName",
			baseName: "firstName",
			type: "string",
		},
		{
			name: "lastName",
			baseName: "lastName",
			type: "string",
		},
		{
			name: "phoneNumber",
			baseName: "phoneNumber",
			type: "string",
		},
	];

	static getAttributeTypeMap() {
		return UserInfoResponse.attributeTypeMap;
	}
}

/**
 * Represent the information that is attached to any registered user.
 */
export class UserProfileRequest {
	/**
	 * Represents the first name of the user
	 */
	"firstName"?: string;
	/**
	 * Represents the last name of the user
	 */
	"lastName"?: string;
	/**
	 * Represents the user's gender
	 */
	"gender"?: UserProfileRequest.GenderEnum;
	/**
	 * Represents the permission given by the user to collect anonymous information about his activity
	 */
	"agreeToCollectAnonymousInformation"?: boolean;
	/**
	 * Represents the phone number of the user
	 */
	"phoneNumber"?: string;
	/**
	 * Represents zone where the user lives
	 */
	"livingZone"?: string;
	/**
	 * Represents the email of the user
	 */
	"email"?: string;
	/**
	 * Represents information about the user, true if owning a car, false otherwise.
	 */
	"isCarOwner"?: boolean;
	/**
	 * Represents the special type of transportation type that is required by the user
	 */
	"isAccessibleCarRequired"?: boolean;
	/**
	 * Represents the status of the user's payment-method
	 */
	"status"?: UserProfileRequest.StatusEnum;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "firstName",
			baseName: "firstName",
			type: "string",
		},
		{
			name: "lastName",
			baseName: "lastName",
			type: "string",
		},
		{
			name: "gender",
			baseName: "gender",
			type: "UserProfileRequest.GenderEnum",
		},
		{
			name: "agreeToCollectAnonymousInformation",
			baseName: "agreeToCollectAnonymousInformation",
			type: "boolean",
		},
		{
			name: "phoneNumber",
			baseName: "phoneNumber",
			type: "string",
		},
		{
			name: "livingZone",
			baseName: "livingZone",
			type: "string",
		},
		{
			name: "email",
			baseName: "email",
			type: "string",
		},
		{
			name: "isCarOwner",
			baseName: "isCarOwner",
			type: "boolean",
		},
		{
			name: "isAccessibleCarRequired",
			baseName: "isAccessibleCarRequired",
			type: "boolean",
		},
		{
			name: "status",
			baseName: "status",
			type: "UserProfileRequest.StatusEnum",
		},
	];

	static getAttributeTypeMap() {
		return UserProfileRequest.attributeTypeMap;
	}
}

export namespace UserProfileRequest {
	export enum GenderEnum {
		None = <any>"none",
		Male = <any>"male",
		Female = <any>"female",
	}
	export enum StatusEnum {
		None = <any>"none",
		Registered = <any>"registered",
		Verified = <any>"verified",
		Active = <any>"active",
		Suspended = <any>"suspended",
	}
}
/**
 * Represent the information that is attached to any registered user.
 */
export class UserProfileResponse {
	/**
	 * Represents the unique user identity. This identity is created in any Registration
	 */
	"userId"?: string;
	/**
	 * Represents the first name of the user
	 */
	"firstName"?: string;
	/**
	 * Represents the last name of the user
	 */
	"lastName"?: string;
	/**
	 * Represents the user's role
	 */
	"userRole"?: UserProfileResponse.UserRoleEnum;
	/**
	 * Represents the user's gender
	 */
	"gender"?: UserProfileResponse.GenderEnum;
	/**
	 * Represents the permission given by the user to collect anonymous information about his activity
	 */
	"agreeToCollectAnonymousInformation"?: boolean;
	/**
	 * Represents the phone number of the user
	 */
	"phoneNumber"?: string;
	/**
	 * Represents zone where the user lives
	 */
	"livingZone"?: string;
	/**
	 * Represents the email of the user
	 */
	"email"?: string;
	/**
	 * Represents information about the user, true if owning a car, false otherwise.
	 */
	"isCarOwner"?: boolean;
	/**
	 * Represents a special type of user who gets a special price, true if the user is senior citizen, otherwise false.
	 */
	"seniorCitizenClaim"?: UserProfileResponse.SeniorCitizenClaimEnum;
	/**
	 * Represents the special type of transportation type that is required by the user
	 */
	"isAccessibleCarRequired"?: boolean;
	/**
	 * Represents the status of the user's payment-method
	 */
	"status"?: UserProfileResponse.StatusEnum;
	/**
	 * Represents the user's registration date
	 */
	"registrationDate"?: Date;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{
		name: string;
		baseName: string;
		type: string;
	}> = [
		{
			name: "userId",
			baseName: "userId",
			type: "string",
		},
		{
			name: "firstName",
			baseName: "firstName",
			type: "string",
		},
		{
			name: "lastName",
			baseName: "lastName",
			type: "string",
		},
		{
			name: "userRole",
			baseName: "userRole",
			type: "UserProfileResponse.UserRoleEnum",
		},
		{
			name: "gender",
			baseName: "gender",
			type: "UserProfileResponse.GenderEnum",
		},
		{
			name: "agreeToCollectAnonymousInformation",
			baseName: "agreeToCollectAnonymousInformation",
			type: "boolean",
		},
		{
			name: "phoneNumber",
			baseName: "phoneNumber",
			type: "string",
		},
		{
			name: "livingZone",
			baseName: "livingZone",
			type: "string",
		},
		{
			name: "email",
			baseName: "email",
			type: "string",
		},
		{
			name: "isCarOwner",
			baseName: "isCarOwner",
			type: "boolean",
		},
		{
			name: "seniorCitizenClaim",
			baseName: "seniorCitizenClaim",
			type: "UserProfileResponse.SeniorCitizenClaimEnum",
		},
		{
			name: "isAccessibleCarRequired",
			baseName: "isAccessibleCarRequired",
			type: "boolean",
		},
		{
			name: "status",
			baseName: "status",
			type: "UserProfileResponse.StatusEnum",
		},
		{
			name: "registrationDate",
			baseName: "registrationDate",
			type: "Date",
		},
	];

	static getAttributeTypeMap() {
		return UserProfileResponse.attributeTypeMap;
	}
}

export namespace UserProfileResponse {
	export enum UserRoleEnum {
		None = <any>"none",
		User = <any>"user",
		Backoffice = <any>"backoffice",
	}
	export enum GenderEnum {
		None = <any>"none",
		Male = <any>"male",
		Female = <any>"female",
	}
	export enum SeniorCitizenClaimEnum {
		None = <any>"none",
		Claiming = <any>"claiming",
		Confirmed = <any>"confirmed",
		Rejected = <any>"rejected",
	}
	export enum StatusEnum {
		None = <any>"none",
		Registered = <any>"registered",
		Verified = <any>"verified",
		Active = <any>"active",
		Suspended = <any>"suspended",
	}
}

let enumsMap: { [index: string]: any } = {
	"ActiveTravelsResponse.TravelStateEnum":
		ActiveTravelsResponse.TravelStateEnum,
	"CreditCard.StatusEnum": CreditCard.StatusEnum,
	"GtfsRestrictionModel.CodeEnum": GtfsRestrictionModel.CodeEnum,
	"InvoiceDataResponse.PurposeTypeEnum": InvoiceDataResponse.PurposeTypeEnum,
	"PaymentDescriptionQuote.QuoteEnum": PaymentDescriptionQuote.QuoteEnum,
	"PaymentMethodInfo.StatusEnum": PaymentMethodInfo.StatusEnum,
	"PaymentResponse.PaymentMethodEnum": PaymentResponse.PaymentMethodEnum,
	"PaymentResponse.PurposeTypeEnum": PaymentResponse.PurposeTypeEnum,
	"PushNotificationSubscribeRequest.PlatformTypeEnum":
		PushNotificationSubscribeRequest.PlatformTypeEnum,
	"SMSLoginResponse.SmsSendStatusEnum": SMSLoginResponse.SmsSendStatusEnum,
	"SeniorCitizenshipClaim.ClaimEnum": SeniorCitizenshipClaim.ClaimEnum,
	"SpecificVehicle.TypeEnum": SpecificVehicle.TypeEnum,
	"TicketListPriceModel.SeniorCitizenshipStatusEnum":
		TicketListPriceModel.SeniorCitizenshipStatusEnum,
	"TravelBookRequest.PaymentMethodEnum": TravelBookRequest.PaymentMethodEnum,
	"TravelCancellationCostResponse.PaymentTypeEnum":
		TravelCancellationCostResponse.PaymentTypeEnum,
	"TravelHistoryResponse.TravelStateEnum":
		TravelHistoryResponse.TravelStateEnum,
	"TravelHistoryResponse.PayedUsingEnum":
		TravelHistoryResponse.PayedUsingEnum,
	"TravelOptionResponse.StatusEnum": TravelOptionResponse.StatusEnum,
	"TravelOptionState.ProviderEnum": TravelOptionState.ProviderEnum,
	"TravelResponse.StateEnum": TravelResponse.StateEnum,
	"TravelResponse.ProviderEnum": TravelResponse.ProviderEnum,
	"TravelStateExternalRef.ProviderEnum": TravelStateExternalRef.ProviderEnum,
	"TravelStateResponse.StateEnum": TravelStateResponse.StateEnum,
	"TravelStateResponse.PreviousStatesEnum":
		TravelStateResponse.PreviousStatesEnum,
	"TravelStateResponse.ProviderEnum": TravelStateResponse.ProviderEnum,
	"TravelStop.TimeQuoteEnum": TravelStop.TimeQuoteEnum,
	"UserProfileRequest.GenderEnum": UserProfileRequest.GenderEnum,
	"UserProfileRequest.StatusEnum": UserProfileRequest.StatusEnum,
	"UserProfileResponse.UserRoleEnum": UserProfileResponse.UserRoleEnum,
	"UserProfileResponse.GenderEnum": UserProfileResponse.GenderEnum,
	"UserProfileResponse.SeniorCitizenClaimEnum":
		UserProfileResponse.SeniorCitizenClaimEnum,
	"UserProfileResponse.StatusEnum": UserProfileResponse.StatusEnum,
};

let typeMap: { [index: string]: any } = {
	ActiveTravelsResponse: ActiveTravelsResponse,
	AuthenticationTokenRequest: AuthenticationTokenRequest,
	AuthenticationTokenResponse: AuthenticationTokenResponse,
	BackofficeUserInfoResponse: BackofficeUserInfoResponse,
	Bounds: Bounds,
	ChangePasswordRequest: ChangePasswordRequest,
	CreditCard: CreditCard,
	Data: Data,
	Distance: Distance,
	Duration: Duration,
	EmailLoginRequest: EmailLoginRequest,
	EmailRequest: EmailRequest,
	Fare: Fare,
	FreeRide: FreeRide,
	FreeRidesAvailable: FreeRidesAvailable,
	FreeRidesForTravelRequest: FreeRidesForTravelRequest,
	FreeRidesRequest: FreeRidesRequest,
	GeocodedWaypoint: GeocodedWaypoint,
	GetUserFailedResponse: GetUserFailedResponse,
	GtfsRestrictionModel: GtfsRestrictionModel,
	InvoiceDataResponse: InvoiceDataResponse,
	Leg: Leg,
	Location: Location,
	ModelError: ModelError,
	OverviewPolyline: OverviewPolyline,
	PayUsingTravelCardRequest: PayUsingTravelCardRequest,
	PaymentDescriptionQuote: PaymentDescriptionQuote,
	PaymentMethodInfo: PaymentMethodInfo,
	PaymentMethodRequest: PaymentMethodRequest,
	PaymentResponse: PaymentResponse,
	PushNotificationSubscribeRequest: PushNotificationSubscribeRequest,
	RefundDelayedCanclationFactorsListUpdateRequest: RefundDelayedCanclationFactorsListUpdateRequest,
	RefundDelayedCanclationTimeFrame: RefundDelayedCanclationTimeFrame,
	ReservedPlaceLineResponse: ReservedPlaceLineResponse,
	Route: Route,
	RouteOptionsResponse: RouteOptionsResponse,
	RouteStop: RouteStop,
	RouteStopTime: RouteStopTime,
	SMSLoginRequest: SMSLoginRequest,
	SMSLoginResponse: SMSLoginResponse,
	SMSLoginVerificationRequest: SMSLoginVerificationRequest,
	SMSRequest: SMSRequest,
	SeniorCitizenshipClaim: SeniorCitizenshipClaim,
	SpecificVehicle: SpecificVehicle,
	StopTimeModel: StopTimeModel,
	TextCatalogLine: TextCatalogLine,
	TicketListPriceModel: TicketListPriceModel,
	TicketPriceTimeFrame: TicketPriceTimeFrame,
	TicketRefundCreditFactorsListUpdateRequest: TicketRefundCreditFactorsListUpdateRequest,
	TicketRefundCreditFrame: TicketRefundCreditFrame,
	TransitStep: TransitStep,
	Travel: Travel,
	TravelBookRequest: TravelBookRequest,
	TravelCancellationCostResponse: TravelCancellationCostResponse,
	TravelCardListPriceRequest: TravelCardListPriceRequest,
	TravelCardOfferResponse: TravelCardOfferResponse,
	TravelCardRequest: TravelCardRequest,
	TravelCardResponse: TravelCardResponse,
	TravelFeedback: TravelFeedback,
	TravelFeedbackRequest: TravelFeedbackRequest,
	TravelHistoryResponse: TravelHistoryResponse,
	TravelOptionResponse: TravelOptionResponse,
	TravelOptionState: TravelOptionState,
	TravelResponse: TravelResponse,
	TravelRide: TravelRide,
	TravelStateExternalRef: TravelStateExternalRef,
	TravelStateResponse: TravelStateResponse,
	TravelStop: TravelStop,
	UserInfoResponse: UserInfoResponse,
	UserProfileRequest: UserProfileRequest,
	UserProfileResponse: UserProfileResponse,
};

export interface Authentication {
	/**
	 * Apply authentication settings to header and query params.
	 */
	applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
	public username: string = "";
	public password: string = "";

	applyToRequest(requestOptions: localVarRequest.Options): void {
		requestOptions.auth = {
			username: this.username,
			password: this.password,
		};
	}
}

export class ApiKeyAuth implements Authentication {
	public apiKey: string = "";

	constructor(private location: string, private paramName: string) {}

	applyToRequest(requestOptions: localVarRequest.Options): void {
		if (this.location == "query") {
			(<any>requestOptions.qs)[this.paramName] = this.apiKey;
		} else if (
			this.location == "header" &&
			requestOptions &&
			requestOptions.headers
		) {
			requestOptions.headers[this.paramName] = this.apiKey;
		}
	}
}

export class OAuth implements Authentication {
	public accessToken: string = "";

	applyToRequest(requestOptions: localVarRequest.Options): void {
		if (requestOptions && requestOptions.headers) {
			requestOptions.headers["Authorization"] =
				"Bearer " + this.accessToken;
		}
	}
}

export class VoidAuth implements Authentication {
	public username: string = "";
	public password: string = "";

	applyToRequest(_: localVarRequest.Options): void {
		// Do nothing
	}
}

export enum AuthApiApiKeys {
	Bearer,
	"internal-secret",
	"x-api-key",
}

export class AuthApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		default: <Authentication>new VoidAuth(),
		Bearer: new ApiKeyAuth("header", "Authorization"),
		"internal-secret": new ApiKeyAuth("header", "internal-secret"),
		"x-api-key": new ApiKeyAuth("header", "x-api-key"),
	};

	constructor(basePath?: string);
	constructor(
		basePathOrUsername: string,
		password?: string,
		basePath?: string
	) {
		if (password) {
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername;
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: AuthApiApiKeys, value: string) {
		(this.authentications as any)[AuthApiApiKeys[key]].apiKey = value;
	}
	/**
	 *
	 * @summary Request to authenticate a new (or existing) user using a given phone number.
	 * @param phoneNumber The phone number that will be used for the authentication of the user.
	 * @param {*} [options] Override http request options.
	 */
	public beginRegisterUser(
		phoneNumber?: SMSLoginRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: SMSLoginResponse }> {
		const localVarPath = this.basePath + "/auth/mfa/login";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(phoneNumber, "SMSLoginRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: SMSLoginResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"SMSLoginResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Request to change the password of an existing back-office user.
	 * @param loginRequest The unique user-name and password.
	 * @param {*} [options] Override http request options.
	 */
	public changePassword(
		loginRequest?: ChangePasswordRequest,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: AuthenticationTokenResponse;
	}> {
		const localVarPath = this.basePath + "/auth/email/change-password";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				loginRequest,
				"ChangePasswordRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: AuthenticationTokenResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"AuthenticationTokenResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Completes the authentication by verifying the phoneNumber and the verificationCode.
	 * @param logingVerificationRequest The phone number that was used to send the SMS and the verification code that was sent to the user in that SMS
	 * @param {*} [options] Override http request options.
	 */
	public completeRegisterUser(
		logingVerificationRequest?: SMSLoginVerificationRequest,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: AuthenticationTokenResponse;
	}> {
		const localVarPath = this.basePath + "/auth/mfa/verify";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				logingVerificationRequest,
				"SMSLoginVerificationRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: AuthenticationTokenResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"AuthenticationTokenResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 * Available for back office users
	 * @summary Delete a backoffice user basing on userId.
	 * @param userId
	 * @param {*} [options] Override http request options.
	 */
	public deleteBackofficeUser(
		userId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath =
			this.basePath +
			"/auth/email/users/{userId}".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling deleteBackofficeUser."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "DELETE",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * Available for back office users
	 * @summary Gets the list of all email-based users (i.e., backoffice users).
	 * @param {*} [options] Override http request options.
	 */
	public getBackofficeUsers(
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<BackofficeUserInfoResponse>;
	}> {
		const localVarPath = this.basePath + "/auth/email/users";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<BackofficeUserInfoResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<BackofficeUserInfoResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Request to authenticate an existing back-office user using it's email and password.
	 * @param login The user name and the password to use to authenticate the user.
	 * @param {*} [options] Override http request options.
	 */
	public loginByEmail(
		login?: EmailLoginRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/auth/email/login";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(login, "EmailLoginRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Refresh the given token.
	 * @param refreshToken The authentication token that should be refreshed.
	 * @param {*} [options] Override http request options.
	 */
	public refreshToken(
		refreshToken?: AuthenticationTokenRequest,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: AuthenticationTokenResponse;
	}> {
		const localVarPath = this.basePath + "/auth/token/refresh";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				refreshToken,
				"AuthenticationTokenRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: AuthenticationTokenResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"AuthenticationTokenResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Request to create a new back-office user.
	 * @param loginRequest The unique user-name and password.
	 * @param {*} [options] Override http request options.
	 */
	public registerUser(
		loginRequest?: EmailLoginRequest,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: AuthenticationTokenResponse;
	}> {
		const localVarPath = this.basePath + "/auth/email/register";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(loginRequest, "EmailLoginRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: AuthenticationTokenResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"AuthenticationTokenResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
export enum MessagingApiApiKeys {
	Bearer,
	"internal-secret",
	"x-api-key",
}

export class MessagingApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		default: <Authentication>new VoidAuth(),
		Bearer: new ApiKeyAuth("header", "Authorization"),
		"internal-secret": new ApiKeyAuth("header", "internal-secret"),
		"x-api-key": new ApiKeyAuth("header", "x-api-key"),
	};

	constructor(basePath?: string);
	constructor(
		basePathOrUsername: string,
		password?: string,
		basePath?: string
	) {
		if (password) {
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername;
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: MessagingApiApiKeys, value: string) {
		(this.authentications as any)[MessagingApiApiKeys[key]].apiKey = value;
	}
	/**
	 *
	 * @summary Gets a text catalog by language
	 * @param language the name of the language that the catalog should be returned
	 * @param {*} [options] Override http request options.
	 */
	public getTextCatalog(
		language: string,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<TextCatalogLine>;
	}> {
		const localVarPath =
			this.basePath +
			"/messaging/text-catalog/{language}".replace(
				"{" + "language" + "}",
				encodeURIComponent(String(language))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'language' is not null or undefined
		if (language === null || language === undefined) {
			throw new Error(
				"Required parameter language was null or undefined when calling getTextCatalog."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<TextCatalogLine>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<TextCatalogLine>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Sends email message.
	 * @param body
	 * @param {*} [options] Override http request options.
	 */
	public sendEmail(
		body?: EmailRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/messaging/email";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(body, "EmailRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Sends sms message.
	 * @param body
	 * @param {*} [options] Override http request options.
	 */
	public sendSms(
		body?: SMSRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/messaging/sms";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(body, "SMSRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Sets the text catalog for the given language
	 * @param language the name of the language that the catalog should be saved to.
	 * @param catalog
	 * @param {*} [options] Override http request options.
	 */
	public setTextCatalog(
		language: string,
		catalog?: Array<TextCatalogLine>,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath =
			this.basePath +
			"/messaging/text-catalog/{language}".replace(
				"{" + "language" + "}",
				encodeURIComponent(String(language))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'language' is not null or undefined
		if (language === null || language === undefined) {
			throw new Error(
				"Required parameter language was null or undefined when calling setTextCatalog."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(catalog, "Array<TextCatalogLine>"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Subscribes an Authorized user to receive push notifications.
	 * @param body
	 * @param {*} [options] Override http request options.
	 */
	public subscribeForPushNotifications(
		body?: PushNotificationSubscribeRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath =
			this.basePath + "/messaging/push/subscribe-token/me";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				body,
				"PushNotificationSubscribeRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Unsubscribe an Authorized user for push notifications.
	 * @param {*} [options] Override http request options.
	 */
	public unsubscribeForPushNotifications(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath =
			this.basePath + "/messaging/push/subscribe-token/me";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "DELETE",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
}
export enum PaymentMethodsApiApiKeys {
	Bearer,
	"internal-secret",
	"x-api-key",
}

export class PaymentMethodsApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		default: <Authentication>new VoidAuth(),
		Bearer: new ApiKeyAuth("header", "Authorization"),
		"internal-secret": new ApiKeyAuth("header", "internal-secret"),
		"x-api-key": new ApiKeyAuth("header", "x-api-key"),
	};

	constructor(basePath?: string);
	constructor(
		basePathOrUsername: string,
		password?: string,
		basePath?: string
	) {
		if (password) {
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername;
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: PaymentMethodsApiApiKeys, value: string) {
		(this.authentications as any)[
			PaymentMethodsApiApiKeys[key]
		].apiKey = value;
	}
	/**
	 * Adding the card will actually PAY for the card from the active CreditCard
	 * @summary Buy a new travel-card for the given userId.
	 * @param userId The Id of the authenticated user
	 * @param travelCard The travel-cards that need to be set
	 * @param {*} [options] Override http request options.
	 */
	public buyTravelCard(
		userId: string,
		travelCard?: TravelCardRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: TravelCardResponse }> {
		const localVarPath =
			this.basePath +
			"/payment-methods/travel-cards/user/{userId}".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling buyTravelCard."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(travelCard, "TravelCardRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelCardResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"TravelCardResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the user's available free rides.
	 * @param {*} [options] Override http request options.
	 */
	public getAvailableFreeRides(
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<FreeRidesAvailable>;
	}> {
		const localVarPath =
			this.basePath + "/payment-methods/free-rides/user/me/available";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<FreeRidesAvailable>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<FreeRidesAvailable>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the user's free rides.
	 * @param userId The Id of the authenticated user
	 * @param {*} [options] Override http request options.
	 */
	public getFreeRides(
		userId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: Array<FreeRide> }> {
		const localVarPath =
			this.basePath +
			"/payment-methods/free-rides/user/{userId}".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling getFreeRides."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<FreeRide>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<FreeRide>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the user's payment method.
	 * @param userId The Id of the authenticated user
	 * @param {*} [options] Override http request options.
	 */
	public getPaymentMethod1(
		userId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: CreditCard }> {
		const localVarPath =
			this.basePath +
			"/payment-methods/credit-card/user/{userId}".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling getPaymentMethod1."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: CreditCard;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(body, "CreditCard");
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the user's payment method.
	 * @param {*} [options] Override http request options.
	 */
	public getPaymentMethod2(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: PaymentMethodInfo }> {
		const localVarPath =
			this.basePath + "/payment-methods/credit-card/user/me";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: PaymentMethodInfo;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"PaymentMethodInfo"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets total available of all non-empty user's travel-cards.
	 * @param {*} [options] Override http request options.
	 */
	public getTotalTravelCards(
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<TravelCardResponse>;
	}> {
		const localVarPath =
			this.basePath + "/payment-methods/travel-cards/user/me/available";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<TravelCardResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<TravelCardResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets all non-empty user's travel-cards.
	 * @param {*} [options] Override http request options.
	 */
	public getTravelCard1(
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<TravelCardResponse>;
	}> {
		const localVarPath =
			this.basePath + "/payment-methods/travel-cards/user/me";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<TravelCardResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<TravelCardResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets all non empty user's travel-cards.
	 * @param userId The Id of the authenticated user
	 * @param {*} [options] Override http request options.
	 */
	public getTravelCards(
		userId: string,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<TravelCardResponse>;
	}> {
		const localVarPath =
			this.basePath +
			"/payment-methods/travel-cards/user/{userId}".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling getTravelCards."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<TravelCardResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<TravelCardResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets list of travel-cards offers for the authenticated user
	 * @param {*} [options] Override http request options.
	 */
	public getTravelCardsOffers(
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<TravelCardOfferResponse>;
	}> {
		const localVarPath =
			this.basePath + "/payment-methods/travel-cards/user/me/offers";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<TravelCardOfferResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<TravelCardOfferResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets list of travel-cards offers for the given user
	 * @param userId
	 * @param {*} [options] Override http request options.
	 */
	public getTravelCardsOffers2(
		userId: string,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<TravelCardOfferResponse>;
	}> {
		const localVarPath =
			this.basePath +
			"/payment-methods/travel-cards/user/{userId}/offers".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling getTravelCardsOffers2."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<TravelCardOfferResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<TravelCardOfferResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 * The general logic is to use the cards one-by-one, i.e., complete a card before starting another card.
	 * @summary Punches the given numberOfTickets in one or more of the user's travel-cards.
	 * @param numberOfTickets The number of tickets that should be punched
	 * @param {*} [options] Override http request options.
	 */
	public punchTravelCard2(
		numberOfTickets?: PayUsingTravelCardRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath =
			this.basePath + "/payment-methods/travel-cards/user/me/punch";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				numberOfTickets,
				"PayUsingTravelCardRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Removes the payment method of the authenticated user.
	 * @param {*} [options] Override http request options.
	 */
	public removePaymentMethod(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: PaymentMethodInfo }> {
		const localVarPath =
			this.basePath + "/payment-methods/credit-card/user/me";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "DELETE",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: PaymentMethodInfo;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"PaymentMethodInfo"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Sets the free rides for the given userId.
	 * @param userId The Id of the authenticated user
	 * @param paymentMethod The free rides that need to be set
	 * @param {*} [options] Override http request options.
	 */
	public setFreeRides(
		userId: string,
		paymentMethod?: FreeRidesRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: FreeRide }> {
		const localVarPath =
			this.basePath +
			"/payment-methods/free-rides/user/{userId}".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling setFreeRides."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(paymentMethod, "FreeRidesRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: FreeRide }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(
								body,
								"FreeRide"
							);
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Sets the free rides for the given travelId.
	 * @param travelId The Id of the travel
	 * @param paymentMethod The free rides that need to be set
	 * @param {*} [options] Override http request options.
	 */
	public setFreeRidesForTravel(
		travelId: string,
		paymentMethod?: FreeRidesForTravelRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: FreeRide }> {
		const localVarPath =
			this.basePath +
			"/payment-methods/free-rides/travel/{travelId}".replace(
				"{" + "travelId" + "}",
				encodeURIComponent(String(travelId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'travelId' is not null or undefined
		if (travelId === null || travelId === undefined) {
			throw new Error(
				"Required parameter travelId was null or undefined when calling setFreeRidesForTravel."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				paymentMethod,
				"FreeRidesForTravelRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: FreeRide }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(
								body,
								"FreeRide"
							);
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * This request should be rejected when there are open payment transactions such as when the user is traveling.
	 * @summary Sets the payment method for the given userId.
	 * @param paymentMethod The payment method that need to be set
	 * @param {*} [options] Override http request options.
	 */
	public setPaymentMethod(
		paymentMethod?: PaymentMethodRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: PaymentMethodInfo }> {
		const localVarPath =
			this.basePath + "/payment-methods/credit-card/user/me";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				paymentMethod,
				"PaymentMethodRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: PaymentMethodInfo;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"PaymentMethodInfo"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Sets the payment method for the given userId.
	 * @param userId The Id of the authenticated user
	 * @param paymentMethod The payment method that need to be set
	 * @param {*} [options] Override http request options.
	 */
	public setPaymentMethodId(
		userId: string,
		paymentMethod?: PaymentMethodRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: PaymentMethodInfo }> {
		const localVarPath =
			this.basePath +
			"/payment-methods/credit-card/user/{userId}".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling setPaymentMethodId."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				paymentMethod,
				"PaymentMethodRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: PaymentMethodInfo;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"PaymentMethodInfo"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Buy a new travel-card for the authenticated userId.
	 * @param travelCard The payment method that need to be set
	 * @param {*} [options] Override http request options.
	 */
	public setTravelCard1(
		travelCard?: TravelCardRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: TravelCardResponse }> {
		const localVarPath =
			this.basePath + "/payment-methods/travel-cards/user/me";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(travelCard, "TravelCardRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelCardResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"TravelCardResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
export enum PaymentsApiApiKeys {
	Bearer,
	"internal-secret",
	"x-api-key",
}

export class PaymentsApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		default: <Authentication>new VoidAuth(),
		Bearer: new ApiKeyAuth("header", "Authorization"),
		"internal-secret": new ApiKeyAuth("header", "internal-secret"),
		"x-api-key": new ApiKeyAuth("header", "x-api-key"),
	};

	constructor(basePath?: string);
	constructor(
		basePathOrUsername: string,
		password?: string,
		basePath?: string
	) {
		if (password) {
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername;
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: PaymentsApiApiKeys, value: string) {
		(this.authentications as any)[PaymentsApiApiKeys[key]].apiKey = value;
	}
	/**
	 *
	 * @summary Gets a page of payments by using a filter
	 * @param userId The Id of the user who is paying
	 * @param pageNumber The page of users that requested
	 * @param pageSize The number of users to return in the page
	 * @param sortBy The field that should be used to sort the list
	 * @param sortDirection The sorting direction - asc, desc
	 * @param filter A comma separated pairs of [field:value]. for example:&lt;br /&gt; \&quot;CreatedOn:dddd,PurposeType:travel\&quot;.&lt;br /&gt;Note that in general &#39;field&#39; can be any field of the payment record.
	 * @param {*} [options] Override http request options.
	 */
	public getPaymentsByUserId(
		userId: string,
		pageNumber?: number,
		pageSize?: number,
		sortBy?: string,
		sortDirection?: string,
		filter?: string,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<PaymentResponse>;
	}> {
		const localVarPath =
			this.basePath +
			"/payments/user/{userId}".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling getPaymentsByUserId."
			);
		}

		if (pageNumber !== undefined) {
			localVarQueryParameters["pageNumber"] = ObjectSerializer.serialize(
				pageNumber,
				"number"
			);
		}

		if (pageSize !== undefined) {
			localVarQueryParameters["pageSize"] = ObjectSerializer.serialize(
				pageSize,
				"number"
			);
		}

		if (sortBy !== undefined) {
			localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
				sortBy,
				"string"
			);
		}

		if (sortDirection !== undefined) {
			localVarQueryParameters[
				"sortDirection"
			] = ObjectSerializer.serialize(sortDirection, "string");
		}

		if (filter !== undefined) {
			localVarQueryParameters["filter"] = ObjectSerializer.serialize(
				filter,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<PaymentResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<PaymentResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 * This interface is aimed for back-office users!
	 * @summary Gets all payments with all data required for invoices within a given time frame
	 * @param fromTime The beginning of the time frame in unix-time
	 * @param toTime The end of the time frame in unix-time
	 * @param {*} [options] Override http request options.
	 */
	public reportPaymentsForInvoice(
		fromTime: number,
		toTime: number,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: Buffer }> {
		const localVarPath =
			this.basePath +
			"/payments/invoice-data/report/{fromTime}/{toTime}"
				.replace(
					"{" + "fromTime" + "}",
					encodeURIComponent(String(fromTime))
				)
				.replace(
					"{" + "toTime" + "}",
					encodeURIComponent(String(toTime))
				);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'fromTime' is not null or undefined
		if (fromTime === null || fromTime === undefined) {
			throw new Error(
				"Required parameter fromTime was null or undefined when calling reportPaymentsForInvoice."
			);
		}

		// verify required parameter 'toTime' is not null or undefined
		if (toTime === null || toTime === undefined) {
			throw new Error(
				"Required parameter toTime was null or undefined when calling reportPaymentsForInvoice."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			encoding: null,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: Buffer }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "Buffer");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * This interface is for back-office users!
	 * @summary Gets a page of payments by using a filter
	 * @param pageNumber The page of users that requested
	 * @param pageSize The number of users to return in the page
	 * @param sortBy The field that should be used to sort the list
	 * @param sortDirection The sorting direction - asc, desc
	 * @param filter A comma separated pairs of [field:value]. for example:&lt;br /&gt; \&quot;CreatedOn:dddd,PurposeType:travel\&quot;.&lt;br /&gt;Note that in general &#39;field&#39; can be any field of the payment record.
	 * @param {*} [options] Override http request options.
	 */
	public searchPayments(
		pageNumber?: number,
		pageSize?: number,
		sortBy?: string,
		sortDirection?: string,
		filter?: string,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<PaymentResponse>;
	}> {
		const localVarPath = this.basePath + "/payments/search";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		if (pageNumber !== undefined) {
			localVarQueryParameters["pageNumber"] = ObjectSerializer.serialize(
				pageNumber,
				"number"
			);
		}

		if (pageSize !== undefined) {
			localVarQueryParameters["pageSize"] = ObjectSerializer.serialize(
				pageSize,
				"number"
			);
		}

		if (sortBy !== undefined) {
			localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
				sortBy,
				"string"
			);
		}

		if (sortDirection !== undefined) {
			localVarQueryParameters[
				"sortDirection"
			] = ObjectSerializer.serialize(sortDirection, "string");
		}

		if (filter !== undefined) {
			localVarQueryParameters["filter"] = ObjectSerializer.serialize(
				filter,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<PaymentResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<PaymentResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 * This interface is aimed for back-office users!
	 * @summary Gets all payments with all data required for invoices within a given time frame
	 * @param fromTime The beginning of the time frame in unix-time
	 * @param toTime The end of the time frame in unix-time
	 * @param {*} [options] Override http request options.
	 */
	public searchPaymentsForInvoice(
		fromTime: number,
		toTime: number,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<InvoiceDataResponse>;
	}> {
		const localVarPath =
			this.basePath +
			"/payments/invoice-data/{fromTime}/{toTime}"
				.replace(
					"{" + "fromTime" + "}",
					encodeURIComponent(String(fromTime))
				)
				.replace(
					"{" + "toTime" + "}",
					encodeURIComponent(String(toTime))
				);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'fromTime' is not null or undefined
		if (fromTime === null || fromTime === undefined) {
			throw new Error(
				"Required parameter fromTime was null or undefined when calling searchPaymentsForInvoice."
			);
		}

		// verify required parameter 'toTime' is not null or undefined
		if (toTime === null || toTime === undefined) {
			throw new Error(
				"Required parameter toTime was null or undefined when calling searchPaymentsForInvoice."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<InvoiceDataResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<InvoiceDataResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
export enum PricesApiApiKeys {
	Bearer,
	"internal-secret",
	"x-api-key",
}

export class PricesApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		default: <Authentication>new VoidAuth(),
		Bearer: new ApiKeyAuth("header", "Authorization"),
		"internal-secret": new ApiKeyAuth("header", "internal-secret"),
		"x-api-key": new ApiKeyAuth("header", "x-api-key"),
	};

	constructor(basePath?: string);
	constructor(
		basePathOrUsername: string,
		password?: string,
		basePath?: string
	) {
		if (password) {
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername;
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: PricesApiApiKeys, value: string) {
		(this.authentications as any)[PricesApiApiKeys[key]].apiKey = value;
	}
	/**
	 * * Aimed for back office users only.<br />  Note that when removing a list price for a senior-citizen status - all users have the corresponding citizen claim status cannot be priced and become useless.
	 * @summary Removes the list-price for a ticket for users with the specified senior citizenship status.
	 * @param seniorCitizenshipStatus The senior citizenship status that indicates the travel-card to remove.
	 * @param {*} [options] Override http request options.
	 */
	public deleteTicketListPrice(
		seniorCitizenshipStatus?:
			| "none"
			| "claiming"
			| "confirmed"
			| "rejected",
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/prices/list-price/tickets";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		if (seniorCitizenshipStatus !== undefined) {
			localVarQueryParameters[
				"seniorCitizenshipStatus"
			] = ObjectSerializer.serialize(
				seniorCitizenshipStatus,
				"'none' | 'claiming' | 'confirmed' | 'rejected'"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "DELETE",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * * Aimed for back office users only.<br />  Note that when removing the list price - all purchased travel-cards of this type cannot be priced and become useless.
	 * @summary Removes the list-price for a travel-card with the specified number of tickets.
	 * @param numberOfTickets The number of tickets that indicates the travel-card to remove.
	 * @param {*} [options] Override http request options.
	 */
	public deleteTravelCardListPrice(
		numberOfTickets: number,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/prices/list-price/travel-card";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'numberOfTickets' is not null or undefined
		if (numberOfTickets === null || numberOfTickets === undefined) {
			throw new Error(
				"Required parameter numberOfTickets was null or undefined when calling deleteTravelCardListPrice."
			);
		}

		if (numberOfTickets !== undefined) {
			localVarQueryParameters[
				"numberOfTickets"
			] = ObjectSerializer.serialize(numberOfTickets, "number");
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "DELETE",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * * This interface is for backoffice USE ONLY!<br />
	 * @summary Gets the list-price tables for tickets.
	 * @param {*} [options] Override http request options.
	 */
	public getTicketListPrice(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/prices/list-price/tickets";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * * Aimed for back office users only.<br />  This API can be used to set the refund factors depending on the number of missed-travels.
	 * @summary Sets missed travels refund credit.
	 * @param refundCredit The sorted refund time factor frames.
	 * @param {*} [options] Override http request options.
	 */
	public setRefundCreditListPrice(
		refundCredit?: TicketRefundCreditFactorsListUpdateRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/prices/list-price/refund-credit";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				refundCredit,
				"TicketRefundCreditFactorsListUpdateRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * * Aimed for back office users only.<br />  This API can be used to set the refund for a travel that is delayed.
	 * @summary Sets the refund list-price for a delayed travel.
	 * @param refundDelayedTravelPrice The refund time factor frames.
	 * @param {*} [options] Override http request options.
	 */
	public setRefundListPrice(
		refundDelayedTravelPrice: RefundDelayedCanclationFactorsListUpdateRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/prices/list-price/refund-delay";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'refundDelayedTravelPrice' is not null or undefined
		if (
			refundDelayedTravelPrice === null ||
			refundDelayedTravelPrice === undefined
		) {
			throw new Error(
				"Required parameter refundDelayedTravelPrice was null or undefined when calling setRefundListPrice."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				refundDelayedTravelPrice,
				"RefundDelayedCanclationFactorsListUpdateRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * * Aimed for back office users only.<br />  This API can be used for setting (adding or replacing) the list-price for ticket depending on the senior-citizen claim status.<br />  It is not yet so, but we may define one of the claims to be the default so a claim status that has no list-price will get it.
	 * @summary Sets or creates the list-price for a ticket for users with the specified senior citizenship status.
	 * @param ticketPriceFrames The sorted price list frames.
	 * @param {*} [options] Override http request options.
	 */
	public setTicketListPrice(
		ticketPriceFrames?: TicketListPriceModel,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/prices/list-price/tickets";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				ticketPriceFrames,
				"TicketListPriceModel"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * * This API aimed only for back office users<br />  This API can be used for setting (adding or replacing) the list-price for different travel-cards. Those travel cards are identified by number of tickets.
	 * @summary Sets the list-price for a travel-card of a specific number tickets.
	 * @param ticketPrice The number of tickets to include in the travel-card.
	 * @param {*} [options] Override http request options.
	 */
	public setTravelCardListPrice(
		ticketPrice?: TravelCardListPriceRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/prices/list-price/travel-card";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				ticketPrice,
				"TravelCardListPriceRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
}
export enum RoutesApiApiKeys {
	Bearer,
	"internal-secret",
	"x-api-key",
}

export class RoutesApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		default: <Authentication>new VoidAuth(),
		Bearer: new ApiKeyAuth("header", "Authorization"),
		"internal-secret": new ApiKeyAuth("header", "internal-secret"),
		"x-api-key": new ApiKeyAuth("header", "x-api-key"),
	};

	constructor(basePath?: string);
	constructor(
		basePathOrUsername: string,
		password?: string,
		basePath?: string
	) {
		if (password) {
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername;
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: RoutesApiApiKeys, value: string) {
		(this.authentications as any)[RoutesApiApiKeys[key]].apiKey = value;
	}
	/**
	 *
	 * @summary Gets the polygon by the relevant provider (VIA or Moovit).
	 * @param provider Represents the travel provider.
	 * @param {*} [options] Override http request options.
	 */
	public getProviderPolygon(
		provider: "via" | "moovit",
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath =
			this.basePath +
			"/routes/{provider}/polygon".replace(
				"{" + "provider" + "}",
				encodeURIComponent(String(provider))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'provider' is not null or undefined
		if (provider === null || provider === undefined) {
			throw new Error(
				"Required parameter provider was null or undefined when calling getProviderPolygon."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Gets list of lines with reserved seats service.
	 * @param {*} [options] Override http request options.
	 */
	public getReservedSeatsLines(
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<ReservedPlaceLineResponse>;
	}> {
		const localVarPath = this.basePath + "/routes/reserved-places-lines";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<ReservedPlaceLineResponse>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<ReservedPlaceLineResponse>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the route options.
	 * @param origin The route origin as comma separated lat,lng
	 * @param destination The route destination as comma separated lat,lng
	 * @param transitMode The transit preferences: &#39;bus&#39;, &#39;subway&#39;, &#39;train&#39;, &#39;tram&#39; or &#39;rail&#39; separated by &#39;|&#39;
	 * @param transitRoutingPreference specifies preferences for transit routes: &#39;less_walking&#39; or &#39;fewer_transfers. This parameter is optional&#39;
	 * @param departureTime A unix time represent the travel departure time. This parameter is optional, default value is &#39;now&#39;.
	 * @param numberOfSeats The number of seats that are required by the user
	 * @param accessibleVehicleRequired true is required, otherwise false
	 * @param {*} [options] Override http request options.
	 */
	public getRouteOptions(
		origin: string,
		destination: string,
		transitMode: string,
		transitRoutingPreference?: string,
		departureTime?: number,
		numberOfSeats?: number,
		accessibleVehicleRequired?: boolean,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: RouteOptionsResponse }> {
		const localVarPath = this.basePath + "/routes/options";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'origin' is not null or undefined
		if (origin === null || origin === undefined) {
			throw new Error(
				"Required parameter origin was null or undefined when calling getRouteOptions."
			);
		}

		// verify required parameter 'destination' is not null or undefined
		if (destination === null || destination === undefined) {
			throw new Error(
				"Required parameter destination was null or undefined when calling getRouteOptions."
			);
		}

		// verify required parameter 'transitMode' is not null or undefined
		if (transitMode === null || transitMode === undefined) {
			throw new Error(
				"Required parameter transitMode was null or undefined when calling getRouteOptions."
			);
		}

		if (origin !== undefined) {
			localVarQueryParameters["origin"] = ObjectSerializer.serialize(
				origin,
				"string"
			);
		}

		if (destination !== undefined) {
			localVarQueryParameters["destination"] = ObjectSerializer.serialize(
				destination,
				"string"
			);
		}

		if (transitMode !== undefined) {
			localVarQueryParameters[
				"transit_mode"
			] = ObjectSerializer.serialize(transitMode, "string");
		}

		if (transitRoutingPreference !== undefined) {
			localVarQueryParameters[
				"transit_routing_preference"
			] = ObjectSerializer.serialize(transitRoutingPreference, "string");
		}

		if (departureTime !== undefined) {
			localVarQueryParameters[
				"departure_time"
			] = ObjectSerializer.serialize(departureTime, "number");
		}

		if (numberOfSeats !== undefined) {
			localVarQueryParameters[
				"numberOfSeats"
			] = ObjectSerializer.serialize(numberOfSeats, "number");
		}

		if (accessibleVehicleRequired !== undefined) {
			localVarQueryParameters[
				"accessibleVehicleRequired"
			] = ObjectSerializer.serialize(
				accessibleVehicleRequired,
				"boolean"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: RouteOptionsResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"RouteOptionsResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the route stop times.
	 * @param tripId The trip_id from the route option
	 * @param stopId The stop_id from the stops list
	 * @param fromTime The arrival time - times will begin from this time till the end of the day
	 * @param {*} [options] Override http request options.
	 */
	public getRouteStopTimes(
		tripId?: string,
		stopId?: string,
		fromTime?: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: Array<RouteStopTime> }> {
		const localVarPath = this.basePath + "/routes/stoptimes";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		if (tripId !== undefined) {
			localVarQueryParameters["trip_id"] = ObjectSerializer.serialize(
				tripId,
				"string"
			);
		}

		if (stopId !== undefined) {
			localVarQueryParameters["stop_id"] = ObjectSerializer.serialize(
				stopId,
				"string"
			);
		}

		if (fromTime !== undefined) {
			localVarQueryParameters["fromTime"] = ObjectSerializer.serialize(
				fromTime,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<RouteStopTime>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<RouteStopTime>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the route stop names.
	 * @param tripId The trip_id from the route option
	 * @param startLat The lat of the arrival_stop
	 * @param startLng The lng of the arrival_stop
	 * @param endLat The lat of the departure_stop
	 * @param endLng The lng of the departure_stop
	 * @param {*} [options] Override http request options.
	 */
	public getRouteStops(
		tripId?: string,
		startLat?: string,
		startLng?: string,
		endLat?: string,
		endLng?: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: Array<RouteStop> }> {
		const localVarPath = this.basePath + "/routes/stops";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		if (tripId !== undefined) {
			localVarQueryParameters["trip_id"] = ObjectSerializer.serialize(
				tripId,
				"string"
			);
		}

		if (startLat !== undefined) {
			localVarQueryParameters["start_lat"] = ObjectSerializer.serialize(
				startLat,
				"string"
			);
		}

		if (startLng !== undefined) {
			localVarQueryParameters["start_lng"] = ObjectSerializer.serialize(
				startLng,
				"string"
			);
		}

		if (endLat !== undefined) {
			localVarQueryParameters["end_lat"] = ObjectSerializer.serialize(
				endLat,
				"string"
			);
		}

		if (endLng !== undefined) {
			localVarQueryParameters["end_lng"] = ObjectSerializer.serialize(
				endLng,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<RouteStop>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<RouteStop>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
export enum TravelOptionsApiApiKeys {
	Bearer,
	"internal-secret",
	"x-api-key",
}

export class TravelOptionsApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		default: <Authentication>new VoidAuth(),
		Bearer: new ApiKeyAuth("header", "Authorization"),
		"internal-secret": new ApiKeyAuth("header", "internal-secret"),
		"x-api-key": new ApiKeyAuth("header", "x-api-key"),
	};

	constructor(basePath?: string);
	constructor(
		basePathOrUsername: string,
		password?: string,
		basePath?: string
	) {
		if (password) {
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername;
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: TravelOptionsApiApiKeys, value: string) {
		(this.authentications as any)[
			TravelOptionsApiApiKeys[key]
		].apiKey = value;
	}
	/**
	 *
	 * @summary Gets all the route-option updates for the given request-id.
	 * @param requestId The id of the request for this option.
	 * @param {*} [options] Override http request options.
	 */
	public getTravelOption(
		requestId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: TravelOptionState }> {
		const localVarPath =
			this.basePath +
			"/travel-options/{requestId}".replace(
				"{" + "requestId" + "}",
				encodeURIComponent(String(requestId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'requestId' is not null or undefined
		if (requestId === null || requestId === undefined) {
			throw new Error(
				"Required parameter requestId was null or undefined when calling getTravelOption."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelOptionState;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"TravelOptionState"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
export enum TravelsApiApiKeys {
	Bearer,
	"internal-secret",
	"x-api-key",
}

export class TravelsApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		default: <Authentication>new VoidAuth(),
		Bearer: new ApiKeyAuth("header", "Authorization"),
		"internal-secret": new ApiKeyAuth("header", "internal-secret"),
		"x-api-key": new ApiKeyAuth("header", "x-api-key"),
	};

	constructor(basePath?: string);
	constructor(
		basePathOrUsername: string,
		password?: string,
		basePath?: string
	) {
		if (password) {
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername;
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: TravelsApiApiKeys, value: string) {
		(this.authentications as any)[TravelsApiApiKeys[key]].apiKey = value;
	}
	/**
	 *
	 * @summary Book a new travel for the authenticated user.
	 * @param travelBookRequest The travel that need to be saved
	 * @param {*} [options] Override http request options.
	 */
	public buyTravel(
		travelBookRequest: TravelBookRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: TravelResponse }> {
		const localVarPath = this.basePath + "/travels/book/me";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'travelBookRequest' is not null or undefined
		if (travelBookRequest === null || travelBookRequest === undefined) {
			throw new Error(
				"Required parameter travelBookRequest was null or undefined when calling buyTravel."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(
				travelBookRequest,
				"TravelBookRequest"
			),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(body, "TravelResponse");
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Cancel an active travel for the authenticated user.
	 * @param {*} [options] Override http request options.
	 */
	public cancelTravel(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/travels/state/me/cancel";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "PUT",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * This interface is for back office users!
	 * @summary Ends active travels.
	 * @param travelId The id of the travel that need to be ended.
	 * @param {*} [options] Override http request options.
	 */
	public endActiveTravels(
		travelId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath =
			this.basePath +
			"/travels/active/end/{travelId}".replace(
				"{" + "travelId" + "}",
				encodeURIComponent(String(travelId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'travelId' is not null or undefined
		if (travelId === null || travelId === undefined) {
			throw new Error(
				"Required parameter travelId was null or undefined when calling endActiveTravels."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * This interface is for back office users!
	 * @summary Gets a page of active travels.
	 * @param pageNumber The page of active-travels that is requested
	 * @param pageSize The number of active-travels to return in the page
	 * @param sortBy The field that should be used to sort the list
	 * @param sortDirection The sorting direction - asc, desc
	 * @param filter A comma separated pairs of [field:value]. for example:&lt;br /&gt; \&quot;startedOn:dddd\&quot;.&lt;br /&gt;Note that in general &#39;field&#39; can be any field of the travel record.
	 * @param {*} [options] Override http request options.
	 */
	public getActiveTravels(
		pageNumber?: string,
		pageSize?: string,
		sortBy?: string,
		sortDirection?: string,
		filter?: string,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: ActiveTravelsResponse;
	}> {
		const localVarPath = this.basePath + "/travels/active/search";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		if (pageNumber !== undefined) {
			localVarQueryParameters["pageNumber"] = ObjectSerializer.serialize(
				pageNumber,
				"string"
			);
		}

		if (pageSize !== undefined) {
			localVarQueryParameters["pageSize"] = ObjectSerializer.serialize(
				pageSize,
				"string"
			);
		}

		if (sortBy !== undefined) {
			localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
				sortBy,
				"string"
			);
		}

		if (sortDirection !== undefined) {
			localVarQueryParameters[
				"sortDirection"
			] = ObjectSerializer.serialize(sortDirection, "string");
		}

		if (filter !== undefined) {
			localVarQueryParameters["filter"] = ObjectSerializer.serialize(
				filter,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: ActiveTravelsResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"ActiveTravelsResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 * This interface is for Back-office use ONLY!
	 * @summary Gets the list of references to all the existing travel-states for update
	 * @param {*} [options] Override http request options.
	 */
	public getAllTravelStateRefs(
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: Array<TravelStateExternalRef>;
	}> {
		const localVarPath = this.basePath + "/travels/state";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: Array<TravelStateExternalRef>;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"Array<TravelStateExternalRef>"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the feedback given to the given travel for the authenticated user.
	 * @param travelId The id of the travel that the feedback is related to.
	 * @param {*} [options] Override http request options.
	 */
	public getFeedback(
		travelId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: TravelFeedback }> {
		const localVarPath =
			this.basePath +
			"/travels/feedback/{travelId}".replace(
				"{" + "travelId" + "}",
				encodeURIComponent(String(travelId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'travelId' is not null or undefined
		if (travelId === null || travelId === undefined) {
			throw new Error(
				"Required parameter travelId was null or undefined when calling getFeedback."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelFeedback;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(body, "TravelFeedback");
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the price of the currently running travel cancellation.
	 * @param {*} [options] Override http request options.
	 */
	public getTravelCancelPrice(
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: TravelCancellationCostResponse;
	}> {
		const localVarPath = this.basePath + "/travels/me/cancel-cost";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelCancellationCostResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"TravelCancellationCostResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets the state of the travel of the authenticated user given id.
	 * @param {*} [options] Override http request options.
	 */
	public getTravelState(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: TravelStateResponse }> {
		const localVarPath = this.basePath + "/travels/me/state";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelStateResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"TravelStateResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 * This interface is for back-office ONLY!
	 * @summary Gets the state of a specific travel by the given providerName and providerTravelId.
	 * @param providerName The name of the travel provider
	 * @param providerTravelId The id of the travel that is wanted
	 * @param {*} [options] Override http request options.
	 */
	public getTravelStateByTravelId(
		providerName: string,
		providerTravelId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: TravelStateResponse }> {
		const localVarPath =
			this.basePath +
			"/travels/state/{providerName}/{providerTravelId}"
				.replace(
					"{" + "providerName" + "}",
					encodeURIComponent(String(providerName))
				)
				.replace(
					"{" + "providerTravelId" + "}",
					encodeURIComponent(String(providerTravelId))
				);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'providerName' is not null or undefined
		if (providerName === null || providerName === undefined) {
			throw new Error(
				"Required parameter providerName was null or undefined when calling getTravelStateByTravelId."
			);
		}

		// verify required parameter 'providerTravelId' is not null or undefined
		if (providerTravelId === null || providerTravelId === undefined) {
			throw new Error(
				"Required parameter providerTravelId was null or undefined when calling getTravelStateByTravelId."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelStateResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"TravelStateResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 * This interface is for back office users!
	 * @summary Gets a page of all travels.
	 * @param pageNumber The page of travels that requested
	 * @param pageSize The number of travels to return in the page
	 * @param sortBy The field that should be used to sort the list
	 * @param sortDirection The sorting direction - asc, desc
	 * @param filter A comma separated pairs of [field:value]. for example:&lt;br /&gt; \&quot;startedOn:dddd\&quot;.&lt;br /&gt;Note that in general &#39;field&#39; can be any field of the travel record.
	 * @param {*} [options] Override http request options.
	 */
	public getTravels(
		pageNumber?: string,
		pageSize?: string,
		sortBy?: string,
		sortDirection?: string,
		filter?: string,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: TravelHistoryResponse;
	}> {
		const localVarPath = this.basePath + "/travels/search";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		if (pageNumber !== undefined) {
			localVarQueryParameters["pageNumber"] = ObjectSerializer.serialize(
				pageNumber,
				"string"
			);
		}

		if (pageSize !== undefined) {
			localVarQueryParameters["pageSize"] = ObjectSerializer.serialize(
				pageSize,
				"string"
			);
		}

		if (sortBy !== undefined) {
			localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
				sortBy,
				"string"
			);
		}

		if (sortDirection !== undefined) {
			localVarQueryParameters[
				"sortDirection"
			] = ObjectSerializer.serialize(sortDirection, "string");
		}

		if (filter !== undefined) {
			localVarQueryParameters["filter"] = ObjectSerializer.serialize(
				filter,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelHistoryResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"TravelHistoryResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets a page of a user travels, including feedback and payment.
	 * @param pageNumber The page of travels that requested
	 * @param pageSize The number of travels to return in the page
	 * @param sortBy The field that should be used to sort the list
	 * @param sortDirection The sorting direction - asc, desc
	 * @param filter A comma separated pairs of [field:value]. for example:&lt;br /&gt; \&quot;startedOn:dddd\&quot;.&lt;br /&gt;Note that in general &#39;field&#39; can be any field of the travel record.
	 * @param {*} [options] Override http request options.
	 */
	public getTravelsHistory(
		pageNumber?: string,
		pageSize?: string,
		sortBy?: string,
		sortDirection?: string,
		filter?: string,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: TravelHistoryResponse;
	}> {
		const localVarPath = this.basePath + "/travels/search/me";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		if (pageNumber !== undefined) {
			localVarQueryParameters["pageNumber"] = ObjectSerializer.serialize(
				pageNumber,
				"string"
			);
		}

		if (pageSize !== undefined) {
			localVarQueryParameters["pageSize"] = ObjectSerializer.serialize(
				pageSize,
				"string"
			);
		}

		if (sortBy !== undefined) {
			localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
				sortBy,
				"string"
			);
		}

		if (sortDirection !== undefined) {
			localVarQueryParameters[
				"sortDirection"
			] = ObjectSerializer.serialize(sortDirection, "string");
		}

		if (filter !== undefined) {
			localVarQueryParameters["filter"] = ObjectSerializer.serialize(
				filter,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelHistoryResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"TravelHistoryResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 * This interface is aimed for back-office users!
	 * @summary Gets a travels report within the given time frame (\"   \")
	 * @param fromTime The beginning of the time frame in unix-time
	 * @param toTime The end of the time frame in unix-time
	 * @param filter A comma separated pairs of [field:value]. for example:&lt;br /&gt; \&quot;startedOn:dddd\&quot;.&lt;br /&gt;Note that in general &#39;field&#39; can be any field of the travel record.
	 * @param {*} [options] Override http request options.
	 */
	public getTravelsReport(
		fromTime: number,
		toTime: number,
		filter?: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath =
			this.basePath +
			"/travels/report/{fromTime}/{toTime}"
				.replace(
					"{" + "fromTime" + "}",
					encodeURIComponent(String(fromTime))
				)
				.replace(
					"{" + "toTime" + "}",
					encodeURIComponent(String(toTime))
				);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'fromTime' is not null or undefined
		if (fromTime === null || fromTime === undefined) {
			throw new Error(
				"Required parameter fromTime was null or undefined when calling getTravelsReport."
			);
		}

		// verify required parameter 'toTime' is not null or undefined
		if (toTime === null || toTime === undefined) {
			throw new Error(
				"Required parameter toTime was null or undefined when calling getTravelsReport."
			);
		}

		if (filter !== undefined) {
			localVarQueryParameters["filter"] = ObjectSerializer.serialize(
				filter,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * This interface is for provider only!
	 * @summary Gets a users info by travel id.
	 * @param providerId The id of the travel that user ordered
	 * @param {*} [options] Override http request options.
	 */
	public getUserInfo(
		providerId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: UserInfoResponse }> {
		const localVarPath =
			this.basePath +
			"/travels/user-info/{providerId}".replace(
				"{" + "providerId" + "}",
				encodeURIComponent(String(providerId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'providerId' is not null or undefined
		if (providerId === null || providerId === undefined) {
			throw new Error(
				"Required parameter providerId was null or undefined when calling getUserInfo."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: UserInfoResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"UserInfoResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Place a travel feedback from the authenticated user.
	 * @param feedBack The feed back
	 * @param {*} [options] Override http request options.
	 */
	public setFeedback(
		feedBack: TravelFeedbackRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: TravelFeedback }> {
		const localVarPath = this.basePath + "/travels/feedback";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'feedBack' is not null or undefined
		if (feedBack === null || feedBack === undefined) {
			throw new Error(
				"Required parameter feedBack was null or undefined when calling setFeedback."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(feedBack, "TravelFeedbackRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: TravelFeedback;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(body, "TravelFeedback");
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
export enum UsersApiApiKeys {
	Bearer,
	"internal-secret",
	"x-api-key",
}

export class UsersApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		default: <Authentication>new VoidAuth(),
		Bearer: new ApiKeyAuth("header", "Authorization"),
		"internal-secret": new ApiKeyAuth("header", "internal-secret"),
		"x-api-key": new ApiKeyAuth("header", "x-api-key"),
	};

	constructor(basePath?: string);
	constructor(
		basePathOrUsername: string,
		password?: string,
		basePath?: string
	) {
		if (password) {
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername;
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: UsersApiApiKeys, value: string) {
		(this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
	}
	/**
	 * Available for back office users
	 * @summary Confirms the senior-citizen claim for a specific user.
	 * @param userId The Id of the user to confirm.
	 * @param {*} [options] Override http request options.
	 */
	public confirmSeniorCitizen(
		userId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath =
			this.basePath +
			"/users/{userId}/senior-citizen/confirm".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling confirmSeniorCitizen."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * Note that when deleting the id-picture. the senior-citizen claim is changed to 'none'.
	 * @summary Deletes the picture of the authenticated user's identity card.
	 * @param {*} [options] Override http request options.
	 */
	public deleteIdPicture(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath = this.basePath + "/users/me/id-picture";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "DELETE",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * Note that when deleting the id-picture. the seniors-citizen claim is changed to 'none'.
	 * @summary Deletes the picture of the user's identity card.
	 * @param userId The Id of the authenticated user
	 * @param {*} [options] Override http request options.
	 */
	public deleteIdPicture1(
		userId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath =
			this.basePath +
			"/users/{userId}/id-picture".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling deleteIdPicture1."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "DELETE",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * Response is the picture in a octet-stream object
	 * @summary Gets the user's identity card picture.
	 * @param userId The Id of the authenticated user
	 * @param {*} [options] Override http request options.
	 */
	public downloadIdPicture(
		userId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath =
			this.basePath +
			"/users/{userId}/id-picture".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling downloadIdPicture."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * Response is the picture in a octet-stream object
	 * @summary Gets the picture of the authenticated user's identity card.
	 * @param {*} [options] Override http request options.
	 */
	public downloadIdPicture1(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath = this.basePath + "/users/me/id-picture";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Gets the user's senior-citizen status.
	 * @param userId The Id of the authenticated user
	 * @param {*} [options] Override http request options.
	 */
	public getSeniorCitizen1(
		userId: string,
		options: any = {}
	): Promise<{
		response: http.IncomingMessage;
		body: SeniorCitizenshipClaim;
	}> {
		const localVarPath =
			this.basePath +
			"/users/{userId}/senior-citizen".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling getSeniorCitizen1."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: SeniorCitizenshipClaim;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"SeniorCitizenshipClaim"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets a user profile by userId.
	 * @param userId The Id of user that is requested
	 * @param {*} [options] Override http request options.
	 */
	public getUserById(
		userId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: UserProfileResponse }> {
		const localVarPath =
			this.basePath +
			"/users/{userId}/profile".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling getUserById."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: UserProfileResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"UserProfileResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Gets a user profile of an authenticated user.
	 * @param {*} [options] Override http request options.
	 */
	public getUserByUserName(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: UserProfileResponse }> {
		const localVarPath = this.basePath + "/users/me/profile";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: UserProfileResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"UserProfileResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 * This interface is for back-office users!
	 * @summary Gets user count by filter.
	 * @param {*} [options] Override http request options.
	 */
	public getUserCountByFilter(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/users/stats";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * This interface is for back-office users!
	 * @summary Gets a page of users based on filter, sort and paging.
	 * @param pageNumber The page of users that requested
	 * @param pageSize The number of users to return in the page
	 * @param sortBy The field that should be used to sort the list
	 * @param sortDirection The sorting direction - asc, desc
	 * @param filter A comma separated pairs of [field:value]. for example: \&quot;firstName:some first name,lastName:some last name\&quot;. Note that in general &#39;field&#39; can be any field you see in the userProfile.
	 * @param {*} [options] Override http request options.
	 */
	public getUsersByFilter(
		pageNumber?: string,
		pageSize?: string,
		sortBy?: string,
		sortDirection?: string,
		filter?: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/users/search";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		if (pageNumber !== undefined) {
			localVarQueryParameters["pageNumber"] = ObjectSerializer.serialize(
				pageNumber,
				"string"
			);
		}

		if (pageSize !== undefined) {
			localVarQueryParameters["pageSize"] = ObjectSerializer.serialize(
				pageSize,
				"string"
			);
		}

		if (sortBy !== undefined) {
			localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
				sortBy,
				"string"
			);
		}

		if (sortDirection !== undefined) {
			localVarQueryParameters[
				"sortDirection"
			] = ObjectSerializer.serialize(sortDirection, "string");
		}

		if (filter !== undefined) {
			localVarQueryParameters["filter"] = ObjectSerializer.serialize(
				filter,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * This interface is for back-office users!
	 * @summary Gets a page of users based on filter, sort and paging.
	 * @param fromTime The beginning of the time frame in unix-time
	 * @param toTime The end of the time frame in unix-time
	 * @param filter A comma separated pairs of [field:value]. for example:&lt;br /&gt; \&quot;startedOn:dddd\&quot;.&lt;br /&gt;Note that in general &#39;field&#39; can be any field of the travel record.
	 * @param {*} [options] Override http request options.
	 */
	public getUsersReportByFilter(
		fromTime: number,
		toTime: number,
		filter?: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath =
			this.basePath +
			"/users/report/{fromTime}/{toTime}"
				.replace(
					"{" + "fromTime" + "}",
					encodeURIComponent(String(fromTime))
				)
				.replace(
					"{" + "toTime" + "}",
					encodeURIComponent(String(toTime))
				);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'fromTime' is not null or undefined
		if (fromTime === null || fromTime === undefined) {
			throw new Error(
				"Required parameter fromTime was null or undefined when calling getUsersReportByFilter."
			);
		}

		// verify required parameter 'toTime' is not null or undefined
		if (toTime === null || toTime === undefined) {
			throw new Error(
				"Required parameter toTime was null or undefined when calling getUsersReportByFilter."
			);
		}

		if (filter !== undefined) {
			localVarQueryParameters["filter"] = ObjectSerializer.serialize(
				filter,
				"string"
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "GET",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * Available for back office users
	 * @summary Rejects the senior-citizen claim for a specific user.
	 * @param userId The Id of the user to reject.
	 * @param {*} [options] Override http request options.
	 */
	public rejectSeniorCitizen(
		userId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath =
			this.basePath +
			"/users/{userId}/senior-citizen/reject".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling rejectSeniorCitizen."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Removes the senior-citizen status.
	 * @param userId The Id of the authenticated user
	 * @param {*} [options] Override http request options.
	 */
	public removeSeniorCitize(
		userId: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath =
			this.basePath +
			"/users/{userId}/senior-citizen".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling removeSeniorCitize."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "DELETE",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Removes the senior-citizen claim of the authenticated user.
	 * @param {*} [options] Override http request options.
	 */
	public removeSeniorCitizen(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath = this.basePath + "/users/me/senior-citizen";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "DELETE",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Update an existing user profile.
	 * @param userId The Id of the authenticated user
	 * @param profile The user profile that need to be saved
	 * @param {*} [options] Override http request options.
	 */
	public saveProfile(
		userId: string,
		profile?: UserProfileRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: UserProfileResponse }> {
		const localVarPath =
			this.basePath +
			"/users/{userId}/profile".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling saveProfile."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "PUT",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(profile, "UserProfileRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: UserProfileResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"UserProfileResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Creates profile for a new authenticated that does not exist.
	 * @param profile The user profile that need to be saved
	 * @param {*} [options] Override http request options.
	 */
	public saveProfileByUserName(
		profile?: UserProfileRequest,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: UserProfileResponse }> {
		const localVarPath = this.basePath + "/users/me/profile";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(profile, "UserProfileRequest"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{
			response: http.IncomingMessage;
			body: UserProfileResponse;
		}>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(
						body,
						"UserProfileResponse"
					);
					if (
						response.statusCode &&
						response.statusCode >= 200 &&
						response.statusCode <= 299
					) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	 *
	 * @summary Make a senior-citizen claim for the given userId.
	 * @param {*} [options] Override http request options.
	 */
	public setSeniorCitizen(
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath = this.basePath + "/users/me/senior-citizen/claim";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 *
	 * @summary Updates the authenticated user's profile.
	 * @param profile The user profile that need to be saved
	 * @param {*} [options] Override http request options.
	 */
	public updateProfileByUserName(
		profile?: UserProfileResponse,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body?: any }> {
		const localVarPath = this.basePath + "/users/me/profile";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: "PUT",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
			body: ObjectSerializer.serialize(profile, "UserProfileResponse"),
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * Note that when changing the picture the senior-citizen claim is changed to 'claiming'.
	 * @summary Uploads the picture of the authenticated user's identity card.
	 * @param contentType
	 * @param contentDisposition
	 * @param headers
	 * @param length
	 * @param name
	 * @param fileName
	 * @param contentType2
	 * @param length2
	 * @param {*} [options] Override http request options.
	 */
	public uploadIdPicture(
		contentType?: string,
		contentDisposition?: string,
		headers?: Buffer,
		length?: number,
		name?: string,
		fileName?: string,
		contentType2?: string,
		length2?: number,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath = this.basePath + "/users/me/id-picture";
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		localVarHeaderParams["contentType"] = ObjectSerializer.serialize(
			contentType2,
			"string"
		);
		localVarHeaderParams["length"] = ObjectSerializer.serialize(
			length2,
			"number"
		);
		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		if (contentType !== undefined) {
			localVarFormParams["ContentType"] = ObjectSerializer.serialize(
				contentType,
				"string"
			);
		}

		if (contentDisposition !== undefined) {
			localVarFormParams[
				"ContentDisposition"
			] = ObjectSerializer.serialize(contentDisposition, "string");
		}

		if (headers !== undefined) {
			localVarFormParams["Headers"] = headers;
		}
		localVarUseFormData = true;

		if (length !== undefined) {
			localVarFormParams["Length"] = ObjectSerializer.serialize(
				length,
				"number"
			);
		}

		if (name !== undefined) {
			localVarFormParams["Name"] = ObjectSerializer.serialize(
				name,
				"string"
			);
		}

		if (fileName !== undefined) {
			localVarFormParams["FileName"] = ObjectSerializer.serialize(
				fileName,
				"string"
			);
		}

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
	/**
	 * Response is the picture in a octet-stream object
	 * @summary Uploads the picture of the user's identity card.
	 * @param userId The Id of the authenticated user
	 * @param contentType
	 * @param contentDisposition
	 * @param headers
	 * @param length
	 * @param name
	 * @param fileName
	 * @param {*} [options] Override http request options.
	 */
	public uploadIdPicture1(
		userId: string,
		contentType?: string,
		contentDisposition?: string,
		headers?: Buffer,
		length?: number,
		name?: string,
		fileName?: string,
		options: any = {}
	): Promise<{ response: http.IncomingMessage; body: string }> {
		const localVarPath =
			this.basePath +
			"/users/{userId}/id-picture".replace(
				"{" + "userId" + "}",
				encodeURIComponent(String(userId))
			);
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign(
			{},
			this.defaultHeaders
		);
		let localVarFormParams: any = {};

		// verify required parameter 'userId' is not null or undefined
		if (userId === null || userId === undefined) {
			throw new Error(
				"Required parameter userId was null or undefined when calling uploadIdPicture1."
			);
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		if (contentType !== undefined) {
			localVarFormParams["ContentType"] = ObjectSerializer.serialize(
				contentType,
				"string"
			);
		}

		if (contentDisposition !== undefined) {
			localVarFormParams[
				"ContentDisposition"
			] = ObjectSerializer.serialize(contentDisposition, "string");
		}

		if (headers !== undefined) {
			localVarFormParams["Headers"] = headers;
		}
		localVarUseFormData = true;

		if (length !== undefined) {
			localVarFormParams["Length"] = ObjectSerializer.serialize(
				length,
				"number"
			);
		}

		if (name !== undefined) {
			localVarFormParams["Name"] = ObjectSerializer.serialize(
				name,
				"string"
			);
		}

		if (fileName !== undefined) {
			localVarFormParams["FileName"] = ObjectSerializer.serialize(
				fileName,
				"string"
			);
		}

		let localVarRequestOptions: localVarRequest.Options = {
			method: "POST",
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.Bearer.applyToRequest(localVarRequestOptions);

		this.authentications["internal-secret"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications["x-api-key"].applyToRequest(
			localVarRequestOptions
		);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: string }>(
			(resolve, reject) => {
				localVarRequest(
					localVarRequestOptions,
					(error, response, body) => {
						if (error) {
							reject(error);
						} else {
							body = ObjectSerializer.deserialize(body, "string");
							if (
								response.statusCode &&
								response.statusCode >= 200 &&
								response.statusCode <= 299
							) {
								resolve({ response: response, body: body });
							} else {
								reject({ response: response, body: body });
							}
						}
					}
				);
			}
		);
	}
}
